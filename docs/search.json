[
  {
    "objectID": "lessons/schedule.html",
    "href": "lessons/schedule.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "lessons/schedule.html#workshop-schedule",
    "href": "lessons/schedule.html#workshop-schedule",
    "title": "",
    "section": "Workshop Schedule",
    "text": "Workshop Schedule\n\nDay 1\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n9:00 - 9:15\nWorkshop introduction\nWill\n\n\n9:15 - 9:35\nR Shiny App Structure and Syntax\nWill\n\n\n9:35 - 10:10\nInput options\nWill\n\n\n10:10 - 10:15\nBreak\n\n\n\n10:15 - 10:45\nVisualization and Interactive Visuals\nWill\n\n\n10:45 - 11:00\nPractical\nWill\n\n\n\n\n\nDay 2\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n09:00 - 9:20\nUploading and Downloading Data\nWill\n\n\n9:20 - 10:00\nLayouts\nWill\n\n\n10:00 - 10:05\nBreak\n\n\n\n10:05 - 10:25\nHosting Platforms\nWill\n\n\n10:25 - 10:50\nPractical\nWill\n\n\n10:50 - 11:00\nWorkshop Wrap-up\nWill"
  },
  {
    "objectID": "lessons/01_syntax_and_structure.html",
    "href": "lessons/01_syntax_and_structure.html",
    "title": "Structure and Syntax in RShiny",
    "section": "",
    "text": "In this lesson, you will:\n\nList applications for RShiny apps\nExplain the parts of an RShiny App\nDescribe the flow of information through an RShiny App",
    "crumbs": [
      "Day 1:",
      "Structure and Syntax in RShiny"
    ]
  },
  {
    "objectID": "lessons/01_syntax_and_structure.html#learning-objectives",
    "href": "lessons/01_syntax_and_structure.html#learning-objectives",
    "title": "Structure and Syntax in RShiny",
    "section": "",
    "text": "In this lesson, you will:\n\nDescribe RShiny\nDescribe the structure of an RShiny App\nDefine the syntax needed to create an RShiny App",
    "crumbs": [
      "Day 1:",
      "Structure and Syntax in RShiny"
    ]
  },
  {
    "objectID": "lessons/01_syntax_and_structure.html#what-is-shiny",
    "href": "lessons/01_syntax_and_structure.html#what-is-shiny",
    "title": "Structure and Syntax in RShiny",
    "section": "What is Shiny?",
    "text": "What is Shiny?\nShiny is a package available for both R and Python that allows the user to create a wide variety of interactive web applications (also known as apps). This workshop will focus on using Shiny within R. However, many of the principles from this workshop are applicable to Shiny on Python, but the syntax conforms to Python’s syntax rules rather than R’s.\n\n\n\nBefore we dig too far into the syntax or structure of an app, let’s first look take a look at a gallery of Shiny Apps that have been made by others.\nAs you can see, there are a wide array of use cases for apps made with Shiny.",
    "crumbs": [
      "Day 1:",
      "Structure and Syntax in RShiny"
    ]
  },
  {
    "objectID": "lessons/01_syntax_and_structure.html#rshiny-app-structure",
    "href": "lessons/01_syntax_and_structure.html#rshiny-app-structure",
    "title": "Structure and Syntax in RShiny",
    "section": "RShiny App Structure",
    "text": "RShiny App Structure\nEach Shiny App has 3 main components:\n\nUser Interface (UI) - This section outlines how the app will look and where items are placed. This is referred to as the front-end of the app\nServer - This section provides the instructions for how input data will be processed and returned by the app. This is referred to as the back-end of the app\nshinyApp - This is the line that ties the UI and the server together and launches the app",
    "crumbs": [
      "Day 1:",
      "Structure and Syntax in RShiny"
    ]
  },
  {
    "objectID": "lessons/01_syntax_and_structure.html#setup",
    "href": "lessons/01_syntax_and_structure.html#setup",
    "title": "Structure and Syntax in RShiny",
    "section": "Setup",
    "text": "Setup\nBefore we make our first app, let’s get our RStudio environment set-up:\n\nOpen RStudio\nOn the top menu, click “File” and then “New Project…”\nSelect “New Directory”\nSelect “New Project”\nName your project “Shiny_demo” and then click “Create Project”\n\n\n\n\n\nOn the top menu, click “File”, then “New File &gt;” and then “R Script”\nNext, we want to save this R Script file, so on the top menu, click “File” and then “Save As…”\nSave the file as “app.R” then click “Save”\n\n\n\n\nAt the top of the script add and run the command to load Shiny:\n\nlibrary(shiny)\n\n\n\n\n\n\n\nNote\n\n\n\nIt is very important when you go to host your apps on external platforms that the app is titled “app.R”. Typically app.R will contain code for a single Shiny app, however for this workshop we will paste in multiple apps to demonstrate Shiny’s capabilities.",
    "crumbs": [
      "Day 1:",
      "Structure and Syntax in RShiny"
    ]
  },
  {
    "objectID": "lessons/01_syntax_and_structure.html#your-first-app",
    "href": "lessons/01_syntax_and_structure.html#your-first-app",
    "title": "Structure and Syntax in RShiny",
    "section": "Your first app",
    "text": "Your first app\nLet’s go ahead and create an app to help demonstrate these components and how they tie together. Copy and paste this code into your Rscript, highlight all of the code then send the code to the console using Ctrl + Enter/Return:\n\n# User Interface\nui &lt;- fluidPage(\n    # The input text box\n    textInput(inputId = \"input_text\", \n              label = \"My input text\"),\n    # The output text\n    textOutput(outputId = \"output_text\")\n)\n\n# Server\nserver &lt;- function(input, output){\n    # Render the text\n    output$output_text &lt;- renderText({\n        input$input_text\n    })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\nThe app that returns should look like the one below:\n\n\n\n\nYou can see that while your app is running the console will look something similar to:\n\nListening on http://127.0.0.1:4108\n\nWhen you are running an app, your console will be unavailable. In order to get your console back you need to either close the app or press the red stop sign in the top right of the console. If you relaunch the app (by re-running the shinyApp function), you can view the app in a web browser by:\n\nClicking “Open in Browser” at the top of the the app window\nCopy and paste the URL in your console after “Listening on” into the URL of your preferred web browser\n\n\nUser Interface\nLet’s go line-by line and breakdown the code for the UI:\n\n# DO NOT RUN\n# User Interface\nui &lt;- fluidPage(\n  ...\n)\n\nThe fluidPage() function is a common wrapper used to develop UI’s in Shiny and it is being assigned to the object ui.\n\n# DO NOT RUN\n# The input text box\ntextInput(inputId = \"input_text\",\n          label = \"My input text\")\n\nThere are many types of input and output types in RShiny, we will discuss these types at length in the upcoming lessons. In this example, we are creating a text input using the textInput() function. There are two arguments:\n\nThe first argument is the variable name for the user input to be stored to.\nThe second argument is a character string representing the text which will be placed above the input text box.\n\nBecause this is the first line of code for the user interface, this input text box will appear at the top of the app.\n\n# DO NOT RUN\n# The output text\ntextOutput(outputId = \"output_text\")\n\nThe textOuput() function is telling the UI where to put the output text after it has been rendered by the server. We haven’t seen where the variable output_text is created yet, but we will see it in the server section below.\nImportantly, each line at the same scope in the UI is separated by a comma.\n\n\n\n\n\n\nNote\n\n\n\nYou’ll frequently see Shiny functions written with just the arguments, like textInput(\"input_text\", \"My input text\") or textOutput(\"output_text\"). In this tutorial, we’ll include explicit argument names (e.g., inputId =, label = and outputId =) to help make the code more readable and easier to follow as you’re learning.\n\n\n\n\nServer\nNow let’s investigate the server side of the app:\n\n# DO NOT RUN\n# Server\nserver &lt;- function(input, output){\n  ...\n  })\n\nThe server function is created with the variables input and output to hold the input and output of the app. Inside the function we place the following code:\n\n# DO NOT RUN \n    # Render the text\n    output$output_text &lt;- renderText({\n        input$input_text\n    })\n\nHere, we are using the renderText() function to take the object from textInput() render it as output. We then take that rendering and assign it to output$output_text which ties back to the textOutput() function we had in the UI section of code.\n\n\n\n\n\n\nNote\n\n\n\nThe render[Type]() family of functions are specific to the type of [type]Output(). We will talk about this more in upcoming lessons.",
    "crumbs": [
      "Day 1:",
      "Structure and Syntax in RShiny"
    ]
  },
  {
    "objectID": "lessons/01_syntax_and_structure.html#putting-it-all-together",
    "href": "lessons/01_syntax_and_structure.html#putting-it-all-together",
    "title": "Structure and Syntax in RShiny",
    "section": "Putting it all together",
    "text": "Putting it all together\nNow that we’ve gone through each line, let’s talk about what happens when we run the shinyApp() function to tie it all together.\n\nThe input text is entered into the box created by textInput() and saved as input$input_text\nThis input$input_text object is sent to the server which sees that input$input_text is used to create the rendered text for output$output_text.\nThis output$output_text output is then sent back to the UI where it is displayed in the textOutput() fucntion\n\nThe diagram below illustrates how this works.\n\n\n\nNow that we have created our first Shiny app in R, we will explore various input and output options in the next lessons.\n\n\n\n\n\n\nExercise 2\n\n\n\n\nName the three parts of an RShiny app and give a brief explanation of each part.\nIn the basic app that we created in this lesson:\n\n\n# User Interface\nui &lt;- fluidPage(\n    # The input text box\n    textInput(inputId = \"input_text\", \n              label = \"My input text\"),\n    # The output text\n    textOutput(outputId = \"output_text\")\n)\n\n# Server\nserver &lt;- function(input, output){\n    # Render the text\n    output$output_text &lt;- renderText({\n        input$input_text\n    })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\nDescribe what information input$input_text and output$output_text holds.\n\n\n\nNext Lesson &gt;&gt;\nBack to Schedule\n\nThis lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.",
    "crumbs": [
      "Day 1:",
      "Structure and Syntax in RShiny"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "index.html#installation-requirements",
    "href": "index.html#installation-requirements",
    "title": "",
    "section": "Installation Requirements",
    "text": "Installation Requirements\nDownload the most recent versions of R and RStudio for your laptop:\n\nR (version 4.3.0 or above)\nRStudio\n\n\n\n\n\n\n\nNote\n\n\n\nIf you have a Mac, download and install this tool before installing your packages if using R versions 4.3.0 up to 4.4.3 or this tool if using R versions after 4.4.3."
  },
  {
    "objectID": "index.html#r-package-requirements",
    "href": "index.html#r-package-requirements",
    "title": "",
    "section": "R Package requirements:",
    "text": "R Package requirements:\nInstall the 4 packages listed below from CRAN using the install.packages() function.\n\ninstall.packages(\"shiny\")\ninstall.packages(\"tidyverse\")\ninstall.packages(\"shinythemes\")\ninstall.packages(\"DT\")"
  },
  {
    "objectID": "index.html#additional-resources",
    "href": "index.html#additional-resources",
    "title": "",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nMastering Shiny"
  },
  {
    "objectID": "index.html#interesting-input-widgets",
    "href": "index.html#interesting-input-widgets",
    "title": "",
    "section": "Interesting Input Widgets",
    "text": "Interesting Input Widgets\n\nPicker\nshinyChakraSlider"
  },
  {
    "objectID": "lessons/02_inputs.html",
    "href": "lessons/02_inputs.html",
    "title": "Input functions in RShiny",
    "section": "",
    "text": "In this lesson, you will:\n\nCreate apps that accept a diverse array of Widget inputs",
    "crumbs": [
      "Day 1:",
      "Input functions in RShiny"
    ]
  },
  {
    "objectID": "lessons/02_inputs.html#learning-objectives",
    "href": "lessons/02_inputs.html#learning-objectives",
    "title": "Input functions in RShiny",
    "section": "",
    "text": "In this lesson, you will:\n\nCreate apps that accept a diverse array of Widget inputs",
    "crumbs": [
      "Day 1:",
      "Input functions in RShiny"
    ]
  },
  {
    "objectID": "lessons/02_inputs.html#text-box",
    "href": "lessons/02_inputs.html#text-box",
    "title": "Input functions in RShiny",
    "section": "Text box",
    "text": "Text box\nSimilar to textInput(), textAreaInput() functions in many of the same ways, but instead of having a single line where you can enter text into, it allows for multi-line input. An example of the code you would use to do that is below:\n\n# User interface\nui &lt;- fluidPage(\n  # Text area input instead of a single line\n  textAreaInput(inputId = \"input_text\",\n                label = \"My input text\"),\n  # The output text\n  textOutput(outputId = \"output_text\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n  # Render the text\n  output$output_text &lt;- renderText({ \n    input$input_text \n    })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\nThis will render an app that looks like:\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf you want to maintain new line character you could use verbatimTextOutput() rather than textOutput(). verbatimTextOutput() will treat the text output exactly like it is entered without any formatting.\n\n\nIf you would like to have some text appear by default in your app’s text area input, you can change:\n\n# DO NOT RUN \ntextAreaInput(inputId = \"input_text\",\n              label = \"My input text\")\n\nTo have a third, placeholder, argument:\n\n# DO NOT RUN \ntextAreaInput(inputId = \"input_text\",\n              label = \"My input text\",\n              placeholder = \"Write about anything you like here...\")\n\nAdding this in creates default text to appear in the box, giving the user an example.",
    "crumbs": [
      "Day 1:",
      "Input functions in RShiny"
    ]
  },
  {
    "objectID": "lessons/02_inputs.html#sliders",
    "href": "lessons/02_inputs.html#sliders",
    "title": "Input functions in RShiny",
    "section": "Sliders",
    "text": "Sliders\nSlider inputs are a great way to provide an interactive range for the user to select a value from. Below we will have the example code that one can use to create a slider input:\n\n# User Interface\nui &lt;- fluidPage(\n  # Slider input\n  sliderInput(inputId = \"input_slider\",\n              label = \"My input slider\",\n              min = 0,\n              max = 10,\n              value = 6),\n  # The text output\n  textOutput(outputId = \"output_text\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n  # Render the slider value as text\n  output$output_text &lt;- renderText({ \n    input$input_slider\n    })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\nThis app would visualize like:\n\n\n\n\nNote that the only line we changed was the textAreaInput() line to sliderInput(). The renderText() function has no issues handling integer or character data types. We also provided arguments to specify the minimum and maximum values and the value we would like the slider to sit at by default. There are some additional sliderInput() arguments provided in the table below:\n\n\n\n\n\n\n\n\nArgument\nDescription\nExample\n\n\n\n\nstep\nThis can define the step size of the slider rather than using the default step size\nstep = 2\n\n\npre\nAllows you to add text prior the value in the slider\npre = \"Sample_\"\n\n\npost\nAllows you to add text after the value in the slider\npost = \"kg\"\n\n\nticks\nAllows you toggle tick marks on/off\nticks = FALSE\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf you would like the slider to contain a range of values, then you would need to use a vector within the value option like value = c(2,6) where the first value is the default “from” position in the range and the second value is the default “to” value in the range.",
    "crumbs": [
      "Day 1:",
      "Input functions in RShiny"
    ]
  },
  {
    "objectID": "lessons/02_inputs.html#dropdown",
    "href": "lessons/02_inputs.html#dropdown",
    "title": "Input functions in RShiny",
    "section": "Dropdown",
    "text": "Dropdown\nOftentimes when you are working with input data, you would like to select some of your data from a list of options. One way of doing this is to have a dropdown list of options and selectInput() is the function you would use to accomplish this. For this function, the additonal argument choices is used to specify all the options in the dropdown.\n\n# User interface\nui &lt;- fluidPage(\n  # Dropdown select menu of options\n  selectInput(inputId = \"input_select\",\n              label = \"My favorite game\",\n              choices = c(\"Pick a game\" = \"\", \"Catan\", \"Carcassonne\", \"Caverna\", \"Twillight Imperium\")),\n  # The output text\n  textOutput(outputId = \"output_text\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n  # Render the selection from the dropdown menu as text\n  output$output_text &lt;- renderText({ \n    input$input_select\n    })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWithin the choices argument, you can see that we made a placeholder value in the first position, \"Pick a game\" = \"\", and this visualizes as the default placeholder. Otherwise, the placeholder will default to the first element in the choice vector.\n\n\nSome additional arguments for selectInput() are provided below:\n\n\n\n\n\n\n\n\nArgument\nDescription\nExample\n\n\n\n\nmultiple\nAllows you to select multiple options from the selection dropdown menu\nmultiple = TRUE\n\n\nselected\nAllows you to define the default selection, otherwise the default selection will be the first item in the list, unless the multiple arugment is TRUE, then it will default to no selection\nselected = \"Twillight Imperium\"\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou can alternatively use selectizeInput() instead of selectInput() to have more control over the dropdown. While this is outside of the scope of this lesson, the documentation for this can be found here.",
    "crumbs": [
      "Day 1:",
      "Input functions in RShiny"
    ]
  },
  {
    "objectID": "lessons/02_inputs.html#radio-buttons",
    "href": "lessons/02_inputs.html#radio-buttons",
    "title": "Input functions in RShiny",
    "section": "Radio buttons",
    "text": "Radio buttons\nIf you would like your user to be able to toggle between various options, then radio buttons might an an option that you are interested in. Below we have an example code for radio buttons:\n\n# User interface\nui &lt;- fluidPage(\n  # Radio buttons for making a selection\n  radioButtons(inputId = \"radio_button_input\",\n               label = \"My favorite ice cream\",\n               choices = c(\"Vanilla\", \"Chocolate\", \"Strawberry\", \"Mint Chocolate Chip\")),\n  # The output text\n  textOutput(outputId = \"output_text\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n  # Render the selection from the radio button as text\n  output$output_text &lt;- renderText({ \n    input$radio_button_input\n  })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\nThis would visualize like:\n\n\n\n\nSome additional arguments you might consider when using radio buttons are:\n\n\n\n\n\n\n\n\nArgument\nDescription\nExample\n\n\n\n\ninline\nAllows you to display the radio buttons horizontally rather than vertically\ninline = TRUE\n\n\nselected\nAllows you to define the default selection, otherwise the default selection will be the first item in the list\nselected = \"Strawberry\"\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou can set selected to be selected = character(0) and no initial option will be selected, but the documentation recommends against this since users will not be able to return back to this default state.",
    "crumbs": [
      "Day 1:",
      "Input functions in RShiny"
    ]
  },
  {
    "objectID": "lessons/02_inputs.html#checkboxes",
    "href": "lessons/02_inputs.html#checkboxes",
    "title": "Input functions in RShiny",
    "section": "Checkboxes",
    "text": "Checkboxes\nThe are two styles of checkboxes that you can choose from. A single checkbox (checkboxInput()) that will return the values of TRUE and FALSE and also a group of checkboxes (checkboxGroupInput()) where you can select multiple items from.\n\ncheckboxInput\nIf we want a single checkbox to toggle then we can use checkboxInput(). An example is below:\n\n# User interface\nui &lt;- fluidPage(\n  # Checkbox for the user to toggle\n  checkboxInput(inputId = \"checkbox_input\",\n                label = \"Apply Benjamini–Hochberg correction\",\n                value = TRUE),\n  # The output text\n  textOutput(outputId = \"output_text\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n  # Render the checkboxes TRUE/FALSE value as text\n  output$output_text &lt;- renderText({ \n    input$checkbox_input\n  })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\nThis would visualize like:\n\n\n\n\nAn additional argument that you might want to use with checkboxInput() is:\n\n\n\n\n\n\n\n\nArgument\nDescription\nExample\n\n\n\n\nvalue\nAllows you set the default to be equal to TRUE or FALSE\nvalue = TRUE\n\n\n\n\n\ncheckboxGroupInput\nSimilar to radio buttons, Shiny apps can provide checkboxes for users to utilize. This can be particularly useful if you would like the users to be able to select multiple options. Let’s look at an example code for this:\n\n# User Interface\nui &lt;- fluidPage(\n  # Multiple checkbox options\n  checkboxGroupInput(inputId = \"checkbox_input\",\n                     label = \"Which fruits do you like?\",\n                     choices = c(\"Orange\", \"Strawberry\", \"Apple\", \"Pinnapple\")),\n  # The output text\n  textOutput(outputId = \"output_text\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n  # Render the TRUE checkbox selections as text\n  output$output_text &lt;- renderText({ \n    input$checkbox_input\n  })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\nThis would visualize like:\n\n\n\n\nAdditional arguments that you might want to use with checkboxGroupInput() are:\n\n\n\n\n\n\n\n\nArgument\nDescription\nExample\n\n\n\n\ninline\nAllows you to display the checkboxes horizontally rather than vertically\ninline = TRUE\n\n\nselected\nAllows you to define the default selection, otherwise the default selection will be nothing checked. You can also have multiple selected options by putting the selected options into a vector\nselected = \"Strawberry\" or selected = c(\"Strawberry\", \"Pinnapple\")",
    "crumbs": [
      "Day 1:",
      "Input functions in RShiny"
    ]
  },
  {
    "objectID": "lessons/02_inputs.html#dates",
    "href": "lessons/02_inputs.html#dates",
    "title": "Input functions in RShiny",
    "section": "Dates",
    "text": "Dates\nThe input widget for dates allows you to select a specific date from a dropdown calendar. There are two functions that allow you to do this:\n\ndateInput(): Selecting a single date\ndateRangeInput(): Selecting a range of dates\n\n\nSingle date\nWhen selecting a single date from a calendar, we can use the dateInput() function. An example is below:\n\n# User interface\nui &lt;- fluidPage(\n  # A dropdown calendar to select a date\n  dateInput(inputId = \"date_input\",\n            label = \"When is this project due?\"),\n  # The output text\n  textOutput(outputId = \"output_text\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n  # Render the date as text\n  output$output_text &lt;- renderText({ \n    as.character(input$date_input)\n  })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\nNote\n\n\n\nWe have had to add the as.character() function around input$date_input otherwise it will return the time in Unix Epoch format.\n\n\nThis would visualize like:\n\n\n\n\nAdditional arguments that you might want to use with dateInput() are:\n\n\n\n\n\n\n\n\nArgument\nDescription\nExample\n\n\n\n\nvalue\nAllows you to set the default day to open the calendar on. If not set, then it will default to the current day in yyyy-mm-dd format\nvalue = “2024-07-24”\n\n\nmin\nAllows you to set the earliest date that can be selected\nmin = \"2024-07-20\"\n\n\nmax\nAllows you to set the latest date that can be selected\nmax = \"2024-07-28\"\n\n\nweekstart\nAllows you to select which day of the week the calendar should start on with Sunday being 0 and incrementing to Saturday being 6\nweekstart = 1\n\n\nlanguage\nAllows you to set the language for the calendar\nlanguage = \"de\"\n\n\ndaysofweekdisabled\nAllows you to make certain days of the week unavailible for selection with Sunday being 0 and incrementing to Saturday being 6. You can also make a vector of values to block out multiple days of the week.\ndaysofweekdisabled = c(0,6)\n\n\n\n\n\nDate Range\nYou can also collect a date range using Shiny. An example of this is below:\n\n# User interface\nui &lt;- fluidPage(\n  # Select a range of dates from the dropdown calendar\n  dateRangeInput(inputId = \"date_input\",\n                 label = \"When is your vacation?\"),\n  # The output text\n  textOutput(outputId = \"output_text\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n  # Render the date range from the calendar selection as text\n  output$output_text &lt;- renderText({ \n    as.character(input$date_input)\n  })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\nThis would look like:\n\n\n\n\nThe same additional arguments that were used with dateInput() also apply here.\n\n\n\n\n\n\n\nExercise 1\n\n\n\nIn this exercise, you will use the input widgets presented above and the associate code to create your own RShiny app! It will take numeric input from a select dropdown menu, radio button and slider and then multiply the values together and return the product. Let’s break this down into a few parts:\n\nCreate the user interface for the app that allows the user to select the values 1-3 from a selectInput() function, the values 4-6 from a radioButtons() function and the values 7-9 from a sliderInput().\nIn the user interface create a place for the output text for the product of these values to appear.\nCreate a server for the app that multiples the three input values together and renders their product as text. Hint: You will need to wrap each input in a as.numeric() function.\nPut the parts together and run the app.",
    "crumbs": [
      "Day 1:",
      "Input functions in RShiny"
    ]
  },
  {
    "objectID": "lessons/02_inputs.html#conditional-panel",
    "href": "lessons/02_inputs.html#conditional-panel",
    "title": "Input functions in RShiny",
    "section": "Conditional Panel",
    "text": "Conditional Panel\nSuppose you want some input appearing to be conditional on another input’s value. This is a good place to utilize the conditionalPanel() function. The general syntax for using conditionalPanel() is:\n\n# DO NOT RUN\nconditionalPanel(\n  condition = \"input.&lt;variable_name&gt; == '&lt;value&gt;'\",\n  &lt;what_to_appear_if_the_condition_is_true&gt;\n)\n\nBelow is an example of using the conditionalPanel(). In this example, the user selects ‘Yes’ or ‘No’, and if they select ‘Yes’, then they are prompted to select from a list of courses that they have taken. If they select ‘No’, there is nothing further.\n\n# User interface\nui &lt;- fluidPage(\n  # Select a value of \"Yes\" or \"No\" from a select dropdown menu \n  selectInput(inputId = \"select_input\",\n              label = \"Have you taken a Current Topics in Bioinformatics module with us before?\", \n              choices = c(\"Please Answer\" = \"\", \"Yes\", \"No\")),\n  # Have a conditional panel\n  conditionalPanel(\n    # If the value of \"select_input\" is \"Yes\"\n    condition = \"input.select_input == 'Yes'\",\n    # Then, inquire as to which courses have they taken with a second select dropdown menu\n    selectInput(inputId = \"select_courses\",\n                label = \"Which courses have you taken?\",\n                choices = c(\"R Basics\", \"Shell basics\", \"Advanced shell\"),\n                multiple = TRUE)\n  ),\n  # The output text of courses taken\n  textOutput(outputId = \"courses\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n  # Render the selection(s) of course(s) taken as text\n  output$courses &lt;- renderText({ \n     input$select_courses\n   })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\nNote\n\n\n\nWhen using boolean values with conditional panels, the ‘&lt;value&gt;’ is 0 for FALSE and 1 for TRUE. Entering the boolean values TRUE or FALSE for these values will not work.\n\n\nThis would look like:",
    "crumbs": [
      "Day 1:",
      "Input functions in RShiny"
    ]
  },
  {
    "objectID": "lessons/02_inputs.html#required-input",
    "href": "lessons/02_inputs.html#required-input",
    "title": "Input functions in RShiny",
    "section": "Required Input",
    "text": "Required Input\nWe may have situation in which the app requires input in order for later code to be evaluated. We can actually see an example of this in the previous app. If you still have the previous app open, select “Yes”, then select a course of your choosing. Next, change the input to “No”. You’ll see that the course selections we’ve made are still present!\nIf we didn’t want this type of contradiction (i.e if they select “No” then there should not be any course selections present), then one way that we could resolve this is with the use of the req() function.\nLet’s look at an example of the req(). On the UI side, nothing has changed. However, on the server side we have placed the req() function inside of renderText(), which tells Shiny that we are requiring input$select_input to be match to “Yes” in order to have the input$select_courses text rendered.\n\n# User interface\nui &lt;- fluidPage(\n  # Select a value of \"Yes\" or \"No\" from a select dropdown menu \n  selectInput(inputId = \"select_input\",\n              label = \"Have you taken a Current Topics in Bioinformatics module with us before?\",\n              choices = c(\"Please Answer\" = \"\", \"Yes\", \"No\")),\n  # Have a conditional panel\n  conditionalPanel(\n    # If the value of \"select_input\" is \"Yes\"\n    condition = \"input.select_input == 'Yes'\",\n    # Then, inquire as to which courses have they taken with a second select dropdown menu\n    selectInput(inputId = \"select_courses\",\n                label = \"Which courses have you taken?\",\n                choices = c(\"R Basics\", \"Shell basics\", \"Advanced shell\"),\n                multiple = TRUE)\n  ),\n  # The output text of courses taken\n  textOutput(outputId = \"courses\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n  # Render the selection(s) of course(s) taken as text  \n  output$courses &lt;- renderText({\n    # Require the the select input to the first question match \"Yes\" in order to evaluate this renderText() function\n    req(input$select_input == \"Yes\")\n    input$select_courses\n  })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\nTest out the app with the “Yes” and “No” options and see how it differs from before!",
    "crumbs": [
      "Day 1:",
      "Input functions in RShiny"
    ]
  },
  {
    "objectID": "lessons/02_inputs.html#shinywidgets",
    "href": "lessons/02_inputs.html#shinywidgets",
    "title": "Input functions in RShiny",
    "section": "shinyWidgets",
    "text": "shinyWidgets\nWe have only scratched the surface of widgets for RShiny! There is so much more you can do, and we encourage you to delve deeper and explore added functionality.\nAlso, to enhance the widget inputs, shinyWidgets is an R package that you can install that gives you even more stylistic options for your Shiny app. The gallery of input widgets that you can create using shinyWidgets can be found here. A useful part of the gallery is that each input widget displayed has a &lt;/&gt; Show code section that gives you the code needed to create the input widget on the UI side.\n\n\n\n\nNext Lesson &gt;&gt;\nBack to Schedule\n\nThis lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.",
    "crumbs": [
      "Day 1:",
      "Input functions in RShiny"
    ]
  },
  {
    "objectID": "lessons/self-learning.html",
    "href": "lessons/self-learning.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "lessons/self-learning.html#learning-objectives",
    "href": "lessons/self-learning.html#learning-objectives",
    "title": "",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nIn this workshop, users will be able to: - Differentiate between the User Interface and Server side of a RShiny App - Create apps that take a variety of input formats, including text, checkboxes, dropdown menus and sliders - Visualize text, figure and table output using an RShiny App - Upload data into an RShiny app and download data and figures from an RShiny app - Discuss the various hosting options for RShiny Apps - Modify R Shiny apps by editing a CSS file"
  },
  {
    "objectID": "lessons/self-learning.html#installations",
    "href": "lessons/self-learning.html#installations",
    "title": "",
    "section": "Installations",
    "text": "Installations\n\nOn your desktop\n\nR\nRStudio\nThe listed R packages"
  },
  {
    "objectID": "lessons/self-learning.html#lessons",
    "href": "lessons/self-learning.html#lessons",
    "title": "",
    "section": "Lessons",
    "text": "Lessons\n\nR Shiny App Structure and Syntax\nInput options\nVisualization and Interactive Visuals\nUploading and Downloading Data\nLayouts\nCustomization\nHosting Platforms\nPractical\n\n\nThese materials have been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited."
  },
  {
    "objectID": "lessons/schedule.html#interesting-input-widgets",
    "href": "lessons/schedule.html#interesting-input-widgets",
    "title": "",
    "section": "Interesting Input Widgets",
    "text": "Interesting Input Widgets\n\nPicker\nshinyChakraSlider\n\n\nThese materials have been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited."
  },
  {
    "objectID": "lessons/advanced_inputs.html",
    "href": "lessons/advanced_inputs.html",
    "title": "Advanced Inputs",
    "section": "",
    "text": "Previously, we have seen the case of input being used to directly create outputs. However, there is third tool in the Shiny toolkit and it is called reactive expressions. Reactive expressions are useful because they take inputs and produce outputs and they cache, or store, their output. This can be very useful for three reasons:\n\nWhen a step is present multiple times in your code and this step that is either computationally intensive or requires interacting with outside databases, Shiny will only need to carry out the task once rather than each time the process is called since the output will be cached for future uses\nIt makes your code cleaner because you only need to maintain the code for a repetitive step in a single place\nThey are needed to use action buttons (discussed in the next section)\n\nBelow we see relationship between input and output that we have seen up to this point:\n\n\n\nAs we see once we add a reactive expression, it functions as a intermediary between inputs and outputs.\n\n\n\nWhen we use a reactive expression, we will wrap it within a reactive() function. We will use a reactive() function in the next section when we use an action button.\n\nNote: You can also have multiple reactive expressions that connect to each other in between inputs and outputs."
  },
  {
    "objectID": "lessons/advanced_inputs.html#reactive-expressions",
    "href": "lessons/advanced_inputs.html#reactive-expressions",
    "title": "Advanced Inputs",
    "section": "",
    "text": "Previously, we have seen the case of input being used to directly create outputs. However, there is third tool in the Shiny toolkit and it is called reactive expressions. Reactive expressions are useful because they take inputs and produce outputs and they cache, or store, their output. This can be very useful for three reasons:\n\nWhen a step is present multiple times in your code and this step that is either computationally intensive or requires interacting with outside databases, Shiny will only need to carry out the task once rather than each time the process is called since the output will be cached for future uses\nIt makes your code cleaner because you only need to maintain the code for a repetitive step in a single place\nThey are needed to use action buttons (discussed in the next section)\n\nBelow we see relationship between input and output that we have seen up to this point:\n\n\n\nAs we see once we add a reactive expression, it functions as a intermediary between inputs and outputs.\n\n\n\nWhen we use a reactive expression, we will wrap it within a reactive() function. We will use a reactive() function in the next section when we use an action button.\n\nNote: You can also have multiple reactive expressions that connect to each other in between inputs and outputs."
  },
  {
    "objectID": "lessons/advanced_inputs.html#action-buttons",
    "href": "lessons/advanced_inputs.html#action-buttons",
    "title": "Advanced Inputs",
    "section": "Action buttons",
    "text": "Action buttons\nAction buttons allow the user to tell Shiny to carry out a given function. This can be helpful when you have a computationally heavy task where you don’t want R to be trying to carry out the computation for each input value as you drag a a slider across its scale. Rather you’d only like for outputs to be computed when you have all of your input parameters set. The syntax for using an action button looks like:\nOn the UI side:\nactionButton(\"inputID\", \"Label\")\nOn the Server side:\nreactive_expression_with_action_button &lt;- bindEvent(reactive(\n    &lt;reactive_expression&gt;\n  ), input$&lt;action_button_inputID&gt;)\nThe actionButton(\"inputID\", \"Label\") line creates our action button in the UI, while bindEvent(reactive(&lt;reactive_expression&gt;), input$&lt;action_button_inputID&gt;) wraps a reactive expression within the bindEvent() function on the server side. Alternatively, you may see in other’s code using a pipe (from the tidyverse package), but this is equivalent code to what is listed above:\nOn the UI side:\nactionButton(\"inputID\", \"Label\")\nOn the server side:\nreactive_expression_with_action_button &lt;- reactive(\n    &lt;reactive_expression&gt;\n  ) &gt;%&gt;\n  bindEvent(input$&lt;action_button_inputID&gt;)\nBelow is some example code on how we could implement this:\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  sliderInput(\"slider_input_1\", \"Select a number\", value = 5, min = 1, max = 10),\n  sliderInput(\"slider_input_2\", \"Select a number\", value = 5, min = 1, max = 10),\n  actionButton(\"calculate\", \"Multiply!\"),\n  textOutput(\"product\")\n)\n\nserver &lt;- function(input, output) {\n  multiply &lt;- bindEvent(reactive(\n    input$slider_input_1 * input$slider_input_2\n  ), input$calculate)\n  output$product &lt;- renderText({ \n    multiply()\n  })\n}\n\nshinyApp(ui = ui, server = server)\nThis app would visualize like:\n\n\n\n\nA wide variety of action button styles exist by adding the class argument to your actionButton() function. Such as:\nactionButton(\"inputID\", \"Label\", class = \"btn-primary\")\n\n\n\nClas\n\n\nDescription\n\n\nExample Code\n\n\nExample\n\n\n\n\nbtn-primary\n\n\nCreates a dark blue button\n\n\nclass = “btn-primary”\n\n\n\n\n\n\n\n\n\nbtn-default / btn-secondary\n\n\nCreates a white button\n\n\nclass = “btn-default” / class = “btn-secondary”\n\n\n\n\n\n\n\n\n\nbtn-warning\n\n\nCreates an orange button\n\n\nclass = “btn-warning”\n\n\n\n\n\n\n\n\n\nbtn-danger\n\n\nCreates a red button\n\n\nclass = “btn-danger”\n\n\n\n\n\n\n\n\n\nbtn-info\n\n\nCreates a light blue button\n\n\nclass = “btn-info”\n\n\n\n\n\n\n\n\n\nbtn-lg\n\n\nCreates a larger button\n\n\nclass = “btn-lg”\n\n\n\n\n\n\n\n\n\nbtn-sm\n\n\nCreates a smaller button\n\n\nclass = “btn-sm”\n\n\n\n\n\n\n\n\n\nbtn-link\n\n\nCreates a hyperlink-style button\n\n\nclass = “btn-link”\n\n\n\n\n\n\n\n\n\nbtn-block\n\n\nCreates a button the width of the page\n\n\nclass = “btn-block”\n\n\n\n\n\n\n\nNote: You can have multiple classes for a given action button as long as each class is separated by a space. For example, if you wanted a large, dark blue action button that goes across the entire browser, then you could use: class = \"btn-primary btn-lg btn-block\". However, whichever non-white color you put last in your list of classes will be the color of the button.\n\n\nNote: bindEvent() is a newer function and it replaces functions like observeEvent() and eventReactive() when coupled with observe() and reactive() function, respectively. It is recommended to use bindEvent() moving forward as it is more flexible, but you may still run across code that utilizes observeEvent() and eventReactive()."
  },
  {
    "objectID": "lessons/advanced_inputs.html#isolate",
    "href": "lessons/advanced_inputs.html#isolate",
    "title": "Advanced Inputs",
    "section": "Isolate",
    "text": "Isolate\nIn Shiny, you may find that you will want to limit the reactivity as we did in the previous example. However, you might want only partial reactivity and this is where the isolate() feature can be quite helpful. You can create a non=-reactive scope around an expression using isolate. The syntax for using isolate() is:\nisolate(&lt;non_reactive_expression&gt;)\nWe can create a similar app to the one above but edit the code to use isolate. In this example, we will see that the first slider is completely reactive, however the second slider is only reacts once the action button has been clicked:\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  sliderInput(\"slider_input_1\", \"Select a number\", value = 5, min = 1, max = 10),\n  sliderInput(\"slider_input_2\", \"Select a number\", value = 5, min = 1, max = 10),\n  actionButton(\"calculate\", \"Multiply!\"),\n  textOutput(\"product\")\n)\n\nserver &lt;- function(input, output) {\n  output$product &lt;- renderText({\n    input$calculate\n    input$slider_input_1 * isolate(input$slider_input_2)\n  })\n}\n\nshinyApp(ui = ui, server = server)\nThis app would look like:\n\n\n\n\n\nNote: If we had used isolate(input$slider_input_1 * input$slider_input_2) instead of input$slider_input_1 * isolate(input$slider_input_2), then this app would function similarly to the app from the previous section since there are now two sliders’ widget inputs are within the isolate() function."
  },
  {
    "objectID": "lessons/shinylive.html",
    "href": "lessons/shinylive.html",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "",
    "text": "In this lesson, you will: - Upload an app to GitHub Pages using Shinylive"
  },
  {
    "objectID": "lessons/shinylive.html#create-an-rstudio-project",
    "href": "lessons/shinylive.html#create-an-rstudio-project",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "Create an RStudio Project",
    "text": "Create an RStudio Project\nThe first step in the process is to create an RStudio project. In order to do this:\n\nGo to your RStudio toolbar and select “File” and then select “New Project”\nA pop-up window should appear where you can select “New Directory” and the window should progress to a allow you to choose “Shiny Application”. One benefit of selecting Shiny Application here is that it will automatically create an R script called “app.R”.\nEnter the name of your RStudio project, in this case we are going to call ours “mtcars_demo”\n(Optional) You can select where you would like this project to be saved to by clicking the “Browse…”. However, we are happy saving it to our Desktop.\nClick “Create Project”\n\nThese steps are shown in the GIF below:"
  },
  {
    "objectID": "lessons/shinylive.html#make-the-app",
    "href": "lessons/shinylive.html#make-the-app",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "Make the app",
    "text": "Make the app\nThe next step in this process is likely the longest step because you now need to make your app! However, we are going to take a shortcut here and use an app that we have already created for this demonstration.\n\nHighlight and delete the default app that came along with create your Shiny application RStudio project\nCopy the RShiny App below by highlighting it and right-clicking the highliughted text and selecting “Copy”\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(DT)\n\nui &lt;- fluidPage(\n  plotOutput(\"plot\", brush = \"plot_brush\"),\n  DTOutput(\"table\")\n)\n\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot(\n    ggplot(mtcars) +\n      geom_point(aes(x = mpg, y = disp))\n  )\n  output$table &lt;- renderDT({\n    brushedPoints(mtcars, input$plot_brush)\n  })\n}\n\nshinyApp(ui = ui, server = server)\n\nRight-click the script editor panel in your RStudio project and select “Paste”\nSave your app by left-clicking on the “Save” icon in RStudio\n\nThese steps are shown in the GIF below:"
  },
  {
    "objectID": "lessons/shinylive.html#create-docs-and-export",
    "href": "lessons/shinylive.html#create-docs-and-export",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "Create docs and export",
    "text": "Create docs and export\nIn order for GitHub Pages to be able to render your Shiny app, you will need to have a specifically named directory called “docs”, which will hold the files output from Shinylive.\n\nClick the “Create a new folder” icon in RStudio\nNamed the new directory “docs”\nWithin the console type the following command:\n\nshinylive::export(appdir = \"../mtcars_demo/\", destdir = \"docs\")\nThis command uses shinylive to export your app found in the app directory (appdir in the command) and direct the output (destdir) into our newly created docs directory.\nThese steps are shown in the GIF below:\n\n\n\n\nNote: The following command will also work:\nshinylive::export(appdir = \".\", destdir = \"docs\")\nHowever, we opted not to use this command in this demo so it would be a bit more clear what the appdir argument was taking in. As a result, we used a relative path to go up a directory then come back down into our current directory. However, for your own work you may opt for this alternative method of directly calling the current directory."
  },
  {
    "objectID": "lessons/shinylive.html#view-with-httpuv-optional-but-strongly-encouraged",
    "href": "lessons/shinylive.html#view-with-httpuv-optional-but-strongly-encouraged",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "View with httpuv (Optional; but strongly encouraged)",
    "text": "View with httpuv (Optional; but strongly encouraged)\nOnce you have created your app with shinylive you will likely want to inspect your app locally to be sure that it is how you want it. This is an optional step, but we recommend visualizing your app at this point as a check to make sure the app was rendered correctly. However, one issue with visualizing your app at this point is that it can’t be visualized through tradional methods of looking at your app. You will instead need to emulate the static webpage and visualize it in there. The httpuv package allows you to visualize static webpages in R.\n\nIn the console enter:\n\nhttpuv::runStaticServer(\"docs/\", port = 8008)\n\nInspect your app within your browser to make sure that it is working correctly\nLeft-click on the stop sign above your R console to stop the app\n\nThese steps are shown in the GIF below:"
  },
  {
    "objectID": "lessons/shinylive.html#make-github-repository",
    "href": "lessons/shinylive.html#make-github-repository",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "Make GitHub Repository",
    "text": "Make GitHub Repository\nNow that we have made the app and prepped it for being on GitHub, we now need to create a GitHub repository ready to hold our app.\n\nNavigate to your GitHub page\nScroll down to the green “New” button to create a new repository on GitHub\nName your repository in the box underneath “Repsitory name”. We named our app shinylive_app and this will be used in the app URL when we are finished\n(Optional) Include a description of your app\nSelect that you would like this repository to be a “Public” repository rather than a “Private” repository\n(Optional) You can check the text box next to “Add a README file” if you would like to have a README file automaically created with your repository\nLeft-click “Create Repository” at the bottom of the webpage\n\nThese steps are shown in the GIF below:"
  },
  {
    "objectID": "lessons/shinylive.html#manage-github-pages-settings",
    "href": "lessons/shinylive.html#manage-github-pages-settings",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "Manage GitHub Pages Settings",
    "text": "Manage GitHub Pages Settings\nNow that we have created our GitHub repository, we will need to edit a few of the settings to allow us to have the Shiny app visualized directory.\n\nIn your repository, left-click on the “Settings” tab\nOn the left-hand side of the webpage, you should now be able to select “Pages” from a menu bar\nLeft-click on the “Branch” dropdown menu and select “main”\nLeft-click on the “Folder” dropdown menu that has just appeared next to the “Branch” dropdown menu and select “/docs”. This is why we had to name our destination directory docs when creating it using shinylive\nLeft-click the “Save” button\n(Optional) You can return back to your code tab on GitHub if you wish, we will not need to adjust any further settings\n\nThese steps are shown in the GIF below:"
  },
  {
    "objectID": "lessons/shinylive.html#clone-your-github-repository",
    "href": "lessons/shinylive.html#clone-your-github-repository",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "Clone your GitHub Repository",
    "text": "Clone your GitHub Repository\nNow that we add created our GitHub repository and gotten the settings right, we now will need to clone (or copy) our repository to our local computers.\n\nOpen GitHub Desktop\nLeft-click on the “Current Repository” tab on the top left corner of GitHub Desktop\nLeft-click on the dropdown menu currently displaying “Add”\nSelect “Clone Repository…”\nType the repository name that you used when creating your repository into the “Filter your repositories” text box. In our case, we type are typing in “shinylive_app”, but by the time we have typed in “shinylive” there is only one option left.\nMake sure the GitHub repository that you want to clone is highlighted\nLeft-click the blue “Clone” button\n\nThese steps are shown in the GIF below:"
  },
  {
    "objectID": "lessons/shinylive.html#copy-app-to-your-cloned-github-repository-and-push-to-the-origin",
    "href": "lessons/shinylive.html#copy-app-to-your-cloned-github-repository-and-push-to-the-origin",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "Copy app to your cloned GitHub Repository and push to the origin",
    "text": "Copy app to your cloned GitHub Repository and push to the origin\nNow that we’ve cloned our GitHub repository locally, we will need to add the “docs” directory from our app’s directory to our cloned GitHub directory.\n\nIn a file browser, right-click on “docs” directory within your app’s directory and select “Copy”\nIn a second file browser open your cloned GitHub repository or by navigating to your cloned GitHub repository in your same file browser, right-click and select “Paste” or “Paste Item”\nIn GitHub Desktop, add a summary for this commit in the “Summary (required)” text box\n(Optional) You can add an optional description for this commit\nLeft-click the blue “Commit to main” button\nAt the top of your GitHub Desktop, left-click the “Push origin” button\n\nThese steps are shown in the GIF below:"
  },
  {
    "objectID": "lessons/shinylive.html#view-your-app-on-github-pages",
    "href": "lessons/shinylive.html#view-your-app-on-github-pages",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "View your app on GitHub Pages",
    "text": "View your app on GitHub Pages\nYou have now uploaded your app to GitHub, so we can look at what it\n\nIn your web browser’s URL enter:\n\nhttps://&lt;github_username&gt;.github.io/&lt;app_name&gt;/\nReplace &lt;github_username&gt; with your GitHub username and &lt;app_name&gt; with your app’s name. Your app should appear after taking a moment to load!\nThese steps are shown in the GIF below:\n\n\n\nCongratulations! You have successfully added your app to a GitHub Pages using shinylive! Now you can share your app with your colleagues without the need of having a server to host your app!\nYou can see the app that we created here."
  },
  {
    "objectID": "lessons/04_uploading_downloading_data.html",
    "href": "lessons/04_uploading_downloading_data.html",
    "title": "Uploading and dowloading data in RShiny",
    "section": "",
    "text": "In this lesson, you will: - Implement reactive expressions - Learn how to incorporate data into your Shiny app - Add functionality to download table data from Shiny app - Download plots created in Shiny app - Create action buttons for a Shiny app",
    "crumbs": [
      "Day 1:",
      "Uploading and dowloading data in RShiny"
    ]
  },
  {
    "objectID": "lessons/04_uploading_downloading_data.html#learning-objectives",
    "href": "lessons/04_uploading_downloading_data.html#learning-objectives",
    "title": "Uploading and dowloading data in RShiny",
    "section": "",
    "text": "In this lesson, you will: - Implement reactive expressions - Learn how to incorporate data into your Shiny app - Add functionality to download table data from Shiny app - Download plots created in Shiny app - Create action buttons for a Shiny app",
    "crumbs": [
      "Day 1:",
      "Uploading and dowloading data in RShiny"
    ]
  },
  {
    "objectID": "lessons/04_uploading_downloading_data.html#action-buttons",
    "href": "lessons/04_uploading_downloading_data.html#action-buttons",
    "title": "Uploading and dowloading data in RShiny",
    "section": "Action Buttons",
    "text": "Action Buttons\nAction buttons allow the user to tell Shiny when to process data. This can be helpful when you have a computationally heavy task where you don’t want R to be trying to carry out the computation for each input value as you drag a a slider across its scale. Rather you’d only like for outputs to be computed when you have all of your input parameters set. The syntax for using an action button looks like:\nOn the UI side:\nactionButton(\"inputID\", \"Label\")\nOn the Server side:\nreactive_expression_with_action_button &lt;- bindEvent(reactive(\n    &lt;reactive_expression&gt;\n  ), input$&lt;action_button_inputID&gt;)\nThe actionButton(\"inputID\", \"Label\") line creates our action button in the UI, while bindEvent(reactive(&lt;reactive_expression&gt;), input$&lt;action_button_inputID&gt;) wraps a reactive expression within the bindEvent() function on the server side. Alternatively, you may see in others’ code using a pipe (see below), but this is equivalent code to what is listed above:\nOn the UI side:\nactionButton(\"inputID\", \"Label\")\nOn the server side:\nreactive_expression_with_action_button &lt;- reactive(\n    &lt;reactive_expression&gt;\n  ) &gt;%&gt;\n  bindEvent(input$&lt;action_button_inputID&gt;)\nBelow is example code on how we could implement this:\n# User interface\nui &lt;- fluidPage(\n    # Slider for the user to select a number between 1 and 10\n    sliderInput(\"slider_input_1\", \"Select a number\", value = 5, min = 1, max = 10),\n    # Slider for the user to select a number between 1 and 10\n    sliderInput(\"slider_input_2\", \"Select a number\", value = 5, min = 1, max = 10),\n    # Action button to tell Shiny to evaluate the multiplication when it is clicked\n    actionButton(\"calculate\", \"Multiply!\"),\n    # The text output\n    textOutput(\"product\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n    # Create a reactive expression that responds to a mouse clicking the action button\n    multiply &lt;- bindEvent(reactive(\n        input$slider_input_1 * input$slider_input_2\n    ), input$calculate)\n    # Render the reactive expression as text\n    output$product &lt;- renderText({ \n        multiply()\n    })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\nThis app would visualize like:\n\n\n\n\nA wide variety of action button styles exist by adding the class argument to your actionButton() function. Such as:\nactionButton(\"inputID\", \"Label\", class = \"btn-primary\")\n\n\nClick here if you would like to see a table of availible action button styles\n\n\n\n\nClass\n\n\nDescription\n\n\nExample Code\n\n\nExample\n\n\n\n\nbtn-primary\n\n\nCreates a dark blue button\n\n\nclass = “btn-primary”\n\n\n\n\n\n\n\n\n\nbtn-default / btn-secondary\n\n\nCreates a white button\n\n\nclass = “btn-default” / class = “btn-secondary”\n\n\n\n\n\n\n\n\n\nbtn-warning\n\n\nCreates an orange button\n\n\nclass = “btn-warning”\n\n\n\n\n\n\n\n\n\nbtn-danger\n\n\nCreates a red button\n\n\nclass = “btn-danger”\n\n\n\n\n\n\n\n\n\nbtn-info\n\n\nCreates a light blue button\n\n\nclass = “btn-info”\n\n\n\n\n\n\n\n\n\nbtn-lg\n\n\nCreates a larger button\n\n\nclass = “btn-lg”\n\n\n\n\n\n\n\n\n\nbtn-sm\n\n\nCreates a smaller button\n\n\nclass = “btn-sm”\n\n\n\n\n\n\n\n\n\nbtn-link\n\n\nCreates a hyperlink-style button\n\n\nclass = “btn-link”\n\n\n\n\n\n\n\n\n\nbtn-block\n\n\nCreates a button the width of the page\n\n\nclass = “btn-block”\n\n\n\n\n\n\n\n\nNote: You can have multiple classes for a given action button as long as each class is separated by a space. For example, if you wanted a large, dark blue action button that goes across the entire browser, then you could use: class = \"btn-primary btn-lg btn-block\". However, whichever non-white color you put last in your list of classes will be the color of the button.\n\n\nNote: bindEvent() is a newer function and when coupled with observe() and reactive() functions, it replaces observeEvent() and eventReactive() functions, respectively. It is recommended to use bindEvent() moving forward as it is more flexible, but you may still run across code that utilizes observeEvent() and eventReactive().",
    "crumbs": [
      "Day 1:",
      "Uploading and dowloading data in RShiny"
    ]
  },
  {
    "objectID": "lessons/04_uploading_downloading_data.html#isolate",
    "href": "lessons/04_uploading_downloading_data.html#isolate",
    "title": "Uploading and dowloading data in RShiny",
    "section": "Isolate",
    "text": "Isolate\nIn Shiny, you may find that you will want to limit the reactivity. However, you might want only partial reactivity and this is where the isolate() feature can be quite helpful. You can create a non-reactive scope around an expression using isolate. The syntax for using isolate() is:\nisolate(&lt;non_reactive_expression&gt;)\nWe can create a similar app to the one above but edit the code to use isolate. In this example, we will see that the first slider is completely reactive, however the second slider is only reacts once the action button has been clicked:\n# User interface\nui &lt;- fluidPage(\n    # Slider for the user to select a number between 1 and 10\n    sliderInput(\"slider_input_1\", \"Select a number\", value = 5, min = 1, max = 10),\n    # Slider for the user to select a number between 1 and 10\n    sliderInput(\"slider_input_2\", \"Select a number\", value = 5, min = 1, max = 10),\n    # The button that will re-process the calculation containing elements within the isolate function after it has been clicked\n    actionButton(\"calculate\", \"Multiply!\"),\n    # The output text\n    textOutput(\"product\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n    # Renders the text for the product of the values from the two sliders\n    # Note that the first slider is not inside an isolate function and will thus react in real-time, while the second slider is within an isolate function, so it will only be evaluated when the action button has been clicked\n    output$product &lt;- renderText({\n        input$calculate\n        input$slider_input_1 * isolate(input$slider_input_2)\n    })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\nThis app would look like:\n\n\n\n\n\nNote: If we had used isolate(input$slider_input_1 * input$slider_input_2) instead of input$slider_input_1 * isolate(input$slider_input_2), then this app would function similarly to the app from the previous section since there are now two sliders’ widget inputs are within the isolate() function.",
    "crumbs": [
      "Day 1:",
      "Uploading and dowloading data in RShiny"
    ]
  },
  {
    "objectID": "lessons/04_uploading_downloading_data.html#uploading-data",
    "href": "lessons/04_uploading_downloading_data.html#uploading-data",
    "title": "Uploading and dowloading data in RShiny",
    "section": "Uploading data",
    "text": "Uploading data\nOften apps are created such that one can explore their own data in some way. To allows users to upload their own data into the app we use the fileInput() function on the UI side:\nfileInput(\"&lt;input_fileID&gt;\", \"&lt;Text_above_file_upload&gt;\")\nThere are some additional options that you might want to consider when using the fileInput() function.\n\n\n\n\n\n\n\n\nArgument\nDescription\nExample\n\n\n\n\nmultiple\nAllows the user to upload multiple files*\nmultiple = TRUE\n\n\naccept\nLimit the file extensions that can be selected by the user\naccept = \".csv\"\n\n\nplaceholder\nText to be entered as a placeholder instead of the “No file selected” default\nplaceholder = \"Waiting for file selection\"\n\n\nbuttonLabel\nText to be entered onto the upload button instead of “Browse…” default\nbuttonLabel = \"Select File...\"\n\n\n\n* Uploading multiple files can be a bit tricky and is outside of the scope of this workshop, but it can be done.\nOn the server side it would look like:\n  uploaded_file &lt;- reactive({\n    req(input$&lt;input_fileID&gt;)\n    read.table(input$&lt;input_fileID&gt;$datapath)\n  })\n  output$table &lt;- renderDT(\n    uploaded_file()\n  )\nThe first part of this code is creating the reactive expression uploaded_file(). We require that the file exist with req(input$&lt;input_fileID&gt;), otherwise Shiny will return an error until we upload a file. Then we read in the file with a function from the read.table() family of functions.\nThe example app for this would look like:\n# User interface\nui &lt;- fluidPage(\n    # File upload button\n    fileInput(\"input_file\", \"Upload your file\"),\n    # The output table\n    DTOutput(\"table\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n    # Create a reactive expression that requires a file have been uploaded and reads in the CSV file that was uploaded\n    uploaded_file &lt;- reactive({\n        req(input$input_file)\n        read.csv(input$input_file$datapath, header = TRUE, row.names = 1)\n    })\n    # Renders the reactive expression as a table\n    output$table &lt;- renderDT(\n        uploaded_file()\n    )\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\nThis app would look like:",
    "crumbs": [
      "Day 1:",
      "Uploading and dowloading data in RShiny"
    ]
  },
  {
    "objectID": "lessons/04_uploading_downloading_data.html#downloading-analysis",
    "href": "lessons/04_uploading_downloading_data.html#downloading-analysis",
    "title": "Uploading and dowloading data in RShiny",
    "section": "Downloading Analysis",
    "text": "Downloading Analysis\nIn the course of doing your analyses, it is likely that you will get to a point where you want to download data stored in a data frame or a plot that you’ve created. Shiny also provides functionality to do this. When you are interested in downloading data or plots, you are going to want to use the downloadButton() (UI side) and downloadHandler() (server side) functions.\n\nDownloading a Data Frame\nIf you have a data frame that you want to download then the important pieces of syntax are:\nOn the UI side:\ndownloadButton(\"&lt;download_buttonID&gt;\", \"Download the data .csv\")\nThe download button is very similar to the actionButton() function that we’ve recently explored. In fact, it also accepts the class argument(s) similar to the actionButton() function.\nOn the server side:\n  output$&lt;download_buttonID&gt; &lt;- downloadHandler(\n    filename = function() {\n      \"&lt;your_placeholder_filename&gt;.csv\"\n    },\n    content = function(file) {\n      write.csv(&lt;your_data_frame&gt;, file, quote = FALSE)\n    }\n)\nOn the server side, we need to use the downloadHandler() function. The downloadHandler() function has two main arguments:\n\nfilename - This is the default filename that will pop-up when you try to save the file.\ncontent - This is the argument where you write your data frame to a file. In this case, we are writing to a .csv, so we use write.csv(). We are writing it to a temporary object called file that downloadHandler() recognizes as the output from content.\n\nAn example app using this is similar to the brushed points example we used previously:\n# User interface\nui &lt;- fluidPage(\n    #  Plot the output with an interactive brushing argument\n    plotOutput(\"plot\", brush = \"plot_brush\"),\n    # The output table\n    DTOutput(\"table\"),\n    # Download button\n    downloadButton(\"download_button\", \"Download the data .csv\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n    # Render a plot from the built-in mtcars dataset\n    output$plot &lt;- renderPlot(\n        ggplot(mtcars) +\n            geom_point(aes(x = mpg, y = disp))\n    )\n    # Reactive expression to hold the brushed points\n    brushed_points &lt;- reactive(\n        brushedPoints(mtcars, input$plot_brush)\n    )\n    # Render a table from brushed points the reactive expression is caching\n    output$table &lt;- renderDT({\n        brushed_points()\n    })\n    # Download the data\n    output$download_button &lt;- downloadHandler(\n        # The placeholder name for the file will be called mtcars_subset.csv\n        filename = function() {\n            \"mtcars_subset.csv\"\n        },\n        # The content of the file will be the contents of the brushed points reactive expression\n        content = function(file) {\n            write.csv(brushed_points(), file, quote = FALSE)\n        }\n    )\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\nIn the above script, we tweaked our script to allow us to download the table containing the brushed points.\n\nWe added a download button to our UI with downloadButton(\"download_button\", \"Download the data .csv\")\nWe moved our brushedPoints() function out of renderDT() and placed it within a reactive() function since we will be calling it twice, once in the renderDT() function and again when we write our data in the downloadHandler() function\nWithin the downloadHandler() function we provided a filename to use as a placeholder (\"mtcars_subset.csv\") as well as defining the content of our .csv file (write.csv(brushed_points(), file, quote = FALSE))\n\nThis app looks like:\n\n\n\n\n\n\nDownloading a plot\nDownloading a plot is similiar to downloading a table. It also uses the downloadButton() and downloadHandler() functions and the arguments are largely similar. The syntax looks like:\nOn the UI side:\ndownloadButton(\"&lt;download_buttonID&gt;\", \"Download the data .png\")\nOn the server side:\n  output$&lt;download_buttonID&gt; &lt;- downloadHandler(\n    filename = function() {\n      \"&lt;your_placeholder_filename&gt;.png\"\n    },\n    content = function(file) {\n      png(file)\n      print(&lt;your_plot&gt;)\n      dev.off()\n    }\n  )\nWe can modify our first plot app to allow us to download the plot:\n# User Interface\nui &lt;- fluidPage(\n    # Dropdown menu to select the column of data to put on the x-axis\n    selectInput(\"x_axis_input\", \"Select x-axis\", choices = colnames(mtcars)),\n    # Dropdown menu to select the column of data to put on the y-axis\n    selectInput(\"y_axis_input\", \"Select y-axis\", choices = colnames(mtcars), selected = \"disp\"),\n    # The output plot\n    plotOutput(\"plot\"),\n    # Download button\n    downloadButton(\"download_button\", \"Download the data .png\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n    # Reactive expression to hold the scatter plot\n    mtcars_plot &lt;- reactive({\n        ggplot(mtcars) +\n            geom_point(aes_string(x = input$x_axis_input, y = input$y_axis_input))\n    })\n    # Render plot from the reactive expression\n    output$plot &lt;- renderPlot({\n        mtcars_plot()\n    })\n    # Download the data\n    output$download_button &lt;- downloadHandler(\n        # The placeholder name for the file will be called mtcars_plot.png\n        filename = function() {\n            \"mtcars_plot.png\"\n        },\n        # The content of the file will be the contents of the mtcars_plot() reactive expression\n        # Note how we need to encapsulate the plot in png() and dev.off() functions\n        # The syntax also demands that we put print() around our plot\n        content = function(file) {\n            png(file)\n            print(mtcars_plot())\n            dev.off()\n        }\n    )\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\nSome key aspects of this app are: - Similarly to when we downloaded the data frame, we have moved our plot function to be within a reactive() function (called mtcars_plot). - Our renderPlot() function called the mtcars_plot() reactive expression. - We call our downloadHandler() function and provide it a default file name of \"mtcars_plot.png\" and for content, we call it mostly the same way as we would write a plot out in R; calling the png() function, plotting our plot, then closing the device with the dev.off() function. The only thing of note here is that we go need to wrap the mtcars_plot() reactive expression within a print() function.\nThis app looks like:",
    "crumbs": [
      "Day 1:",
      "Uploading and dowloading data in RShiny"
    ]
  },
  {
    "objectID": "lessons/06_CSS.html",
    "href": "lessons/06_CSS.html",
    "title": "Customizing apps with CSS in RShiny",
    "section": "",
    "text": "Next Lesson &gt;&gt;\nBack to Schedule\n\nThis lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.",
    "crumbs": [
      "Day 2:",
      "Customizing apps with CSS in RShiny"
    ]
  },
  {
    "objectID": "lessons/05_layouts.html",
    "href": "lessons/05_layouts.html",
    "title": "Arranging Layouts",
    "section": "",
    "text": "In this lesson, you will: - Implement sidebars into your Shiny app - Create tabsets - Implement different shinythemes",
    "crumbs": [
      "Day 2:",
      "Arranging Layouts"
    ]
  },
  {
    "objectID": "lessons/05_layouts.html#nesting-columns",
    "href": "lessons/05_layouts.html#nesting-columns",
    "title": "Arranging Layouts",
    "section": "Nesting columns",
    "text": "Nesting columns\nYou can also nest fluidRow() functions within the column() function of another fluidRow() function. Once again, the important rule when using fluidRow() is that the sum of the column()’s width value within each fluidRow() sums to 12. Let’s take a look at some example syntax of how this would look:\n  fluidRow(\n    column(&lt;width_of_first_main_column&gt;,\n      fluidRow(\n        column(&lt;width_of_first_subcolumn_of_the_first_main_column&gt;,\n          &lt;objects_in_first_column_first_subcolumn&gt;\n        ),\n        column(&lt;width_of_second_subcolumn_of_the_first_main_column&gt;,\n          &lt;objects_in_first_column_second_subcolumn&gt;\n        )\n      )\n    ),\n    column(&lt;width_of_second_main_column&gt;,\n      &lt;objects_in_second_column&gt;\n    )\n  )\n)\nWe can apply these principles to our app:\nlibrary(shiny)\nlibrary(ggplot2)\n\nui &lt;- fluidPage(\n  titlePanel(\n    h1(\"My iris Shiny App\", align = \"center\")\n  ),\n  fluidRow(\n    column(7,\n      fluidRow(\n        column(6,\n        h3(\"First column: First subcolumn\"),\n        selectInput(\"x_axis_input\", \"Select x-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"))\n        ),\n        column(6,\n        h3(\"First column: Second subcolumn\"),\n        selectInput(\"y_axis_input\", \"Select y-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"))\n        )\n      )\n    ),\n    column(5,\n      h3(\"Second column\"),\n      plotOutput(\"plot\")\n    )\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    ggplot(iris) +\n      geom_point(aes(x = .data[[input$x_axis_input]], y = .data[[input$y_axis_input]]))\n  })\n}\n\nshinyApp(ui = ui, server = server)\nThis app would look like:",
    "crumbs": [
      "Day 2:",
      "Arranging Layouts"
    ]
  },
  {
    "objectID": "lessons/05_layouts.html#multiple-rows",
    "href": "lessons/05_layouts.html#multiple-rows",
    "title": "Arranging Layouts",
    "section": "Multiple Rows",
    "text": "Multiple Rows\nNow that we’ve seen how to make multiple columns, let’s breifly talk about multiple rows. Instead of nesting fluidRow() function within one another, we will treat them like we’ve treated objects that go underneath one another, by putting complete fluidRow() functions underneath each other in out code. An example of this syntax can be seen below:\nfluidRow(\n  column(&lt;width_of_first_column_in_the_first_row&gt;,\n    &lt;objects_in_first_column_first_row&gt;\n  ),\n  column(&lt;width_of_second_column_in_the_first_row&gt;,\n    &lt;objects_in_second_column_first_row&gt;\n  )\n),\nfluidRow(\n  column(&lt;width_of_first_column_in_the_second_row&gt;,\n    &lt;objects_in_first_column_second_row&gt;\n  ),\n  column(&lt;width_of_second_column_in_the_second_row&gt;,\n    &lt;objects_in_second_column_second_row&gt;\n  )\n)\nWe can apply the concept of multiple rows to our app:\nlibrary(shiny)\nlibrary(ggplot2)\n\nui &lt;- fluidPage(\n  titlePanel(\n    h1(\"My iris Shiny App\", align = \"center\")\n  ),\n  fluidRow(\n    column(6,\n      h3(\"First Row: First column\"),\n      selectInput(\"x_axis_input\", \"Select x-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"))\n    ),\n      column(6,\n      h3(\"First Row: Second column\"),\n      selectInput(\"y_axis_input\", \"Select y-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"))\n    )\n  ),\n  fluidRow(\n      h3(\"Second Row\"),\n      plotOutput(\"plot\")\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    ggplot(iris) +\n      geom_point(aes(x = .data[[input$x_axis_input]], y = .data[[input$y_axis_input]]))\n  })\n}\n\nshinyApp(ui = ui, server = server)\nThis app would look like:",
    "crumbs": [
      "Day 2:",
      "Arranging Layouts"
    ]
  },
  {
    "objectID": "lessons/05_layouts.html#thematic-breaks",
    "href": "lessons/05_layouts.html#thematic-breaks",
    "title": "Arranging Layouts",
    "section": "Thematic Breaks",
    "text": "Thematic Breaks\nThematic breaks are a great way to break-up different parts of an app. The function to add a themetic break is also borrowed from HTML and it is called hr(). The syntax for using it is very simple:\nhr()\nIn the previous example, if we wanted to break up the selectInput() functions from the plotOutput() function, then we could add a thematic break like:\nlibrary(shiny)\nlibrary(ggplot2)\n\nui &lt;- fluidPage(\n  titlePanel(\n    h1(\"My iris Shiny App\", align = \"center\")\n  ),\n  fluidRow(\n    column(6,\n           h3(\"First Row: First column\"),\n           selectInput(\"x_axis_input\", \"Select x-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"))\n    ),\n    column(6,\n           h3(\"First Row: Second column\"),\n           selectInput(\"y_axis_input\", \"Select y-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"))\n    )\n  ),\n  hr(),\n  fluidRow(\n    h3(\"Second Row\"),\n    plotOutput(\"plot\")\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    ggplot(iris) +\n      geom_point(aes(x = .data[[input$x_axis_input]], y = .data[[input$y_axis_input]]))\n  })\n}\n\nshinyApp(ui = ui, server = server)\nThis app would now look like:",
    "crumbs": [
      "Day 2:",
      "Arranging Layouts"
    ]
  },
  {
    "objectID": "lessons/05_layouts.html#navigation-bar-menu",
    "href": "lessons/05_layouts.html#navigation-bar-menu",
    "title": "Arranging Layouts",
    "section": "Navigation Bar Menu",
    "text": "Navigation Bar Menu\nWithin the navigaton bar, we can have a dropdown menu that gives us more options in a list. This would be accomplished using the navbarMenu() function, which also utilizes tabPanel() function that navbarPage() uses. The syntax for using a dropdown menu anvigation bar menu is:\nnavbarPage(\"&lt;title_of_navigation_bar&gt;\",\n  navbarMenu(\"&lt;name_for_dropdown_menu&gt;\",\n    tabPanel(\"&lt;title_of_option_1_in_menu&gt;\",\n      &lt;content_of_option_1_in_menu&gt;\n    ),\n    tabPanel(\"&lt;title_of_option_2_in_menu&gt;\",\n      &lt;content_of_option_2_in_menu&gt;\n    )\n  )\n)\nA code example of the navbarMenu() function can be seen below:\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(DT)\n\nui &lt;- fluidPage(\n  navbarPage(\"My iris dataset\",\n    tabPanel(\"Inputs\",\n      selectInput(\"x_axis_input\", \"Select x-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\")),\n      selectInput(\"y_axis_input\", \"Select y-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"))\n    ),\n    navbarMenu(\"Outputs\",\n      tabPanel(\"Plot\",\n        plotOutput(\"plot\")\n      ),\n      tabPanel(\"Table\",\n        DTOutput(\"table\")   \n      )\n    )\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    ggplot(iris) +\n      geom_point(aes(x = .data[[input$x_axis_input]], y = .data[[input$y_axis_input]]))\n  })\n  output$table &lt;- renderDT({\n    iris[,c(input$x_axis_input, input$y_axis_input), drop = FALSE]\n  })\n}\n\nshinyApp(ui = ui, server = server)\nThis app would look like:",
    "crumbs": [
      "Day 2:",
      "Arranging Layouts"
    ]
  },
  {
    "objectID": "lessons/05_layouts.html#navigation-list",
    "href": "lessons/05_layouts.html#navigation-list",
    "title": "Arranging Layouts",
    "section": "Navigation List",
    "text": "Navigation List\nIn place of of a navigation bar along the top of the window, you can also opt for a list down the side of the app using the navlistPanel() in place of the navbarPage() function. The syntax for using this style of list looks like:\nnavlistPanel(\"&lt;title_of_navigation_list&gt;\",\n  tabPanel(\"&lt;title_of_tab_1&gt;\",\n    &lt;content_of_tab_1&gt;\n  ),\n  tabPanel(\"&lt;title_of_tab_2&gt;\",\n    &lt;content_of_tab_2&gt;\n  ),\n)\nAn example for this code is below:\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(DT)\n\nui &lt;- fluidPage(\n  navlistPanel(\"My iris dataset\",\n             tabPanel(\"Inputs\",\n                      selectInput(\"x_axis_input\", \"Select x-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\")),\n                      selectInput(\"y_axis_input\", \"Select y-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"))\n             ),\n             navbarMenu(\"Outputs\",\n                        tabPanel(\"Plot\",\n                                 plotOutput(\"plot\")\n                        ),\n                        tabPanel(\"Table\",\n                                 DTOutput(\"table\")   \n                        )\n             )\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    ggplot(iris) +\n      geom_point(aes(x = .data[[input$x_axis_input]], y = .data[[input$y_axis_input]]))\n  })\n  output$table &lt;- renderDT({\n    iris[,c(input$x_axis_input, input$y_axis_input), drop = FALSE]\n  })\n}\n\nshinyApp(ui = ui, server = server)\nThis would create an app that looks like:\n\n\n\n\n\nNote that the navbarMenu() function also works within navlistPanel() just like it works within navbarPage().",
    "crumbs": [
      "Day 2:",
      "Arranging Layouts"
    ]
  },
  {
    "objectID": "lessons/08_practical.html",
    "href": "lessons/08_practical.html",
    "title": "Practical Exercise",
    "section": "",
    "text": "Next Lesson &gt;&gt;\nBack to Schedule\n\nThis lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.",
    "crumbs": [
      "Day 2:",
      "Practical Exercise"
    ]
  },
  {
    "objectID": "lessons/03_visuals.html",
    "href": "lessons/03_visuals.html",
    "title": "Visualization and Interactive Visuals in RShiny",
    "section": "",
    "text": "In this lesson, you will:\n\nImplement a data table output into an app\nCreate an app with a plot output\nDesign an app with an interactive plot",
    "crumbs": [
      "Day 1:",
      "Visualization and Interactive Visuals in RShiny"
    ]
  },
  {
    "objectID": "lessons/03_visuals.html#learning-objectives",
    "href": "lessons/03_visuals.html#learning-objectives",
    "title": "Visualization and Interactive Visuals in RShiny",
    "section": "",
    "text": "In this lesson, you will:\n\nImplement a data table output into an app\nCreate an app with a plot output\nDesign an app with an interactive plot",
    "crumbs": [
      "Day 1:",
      "Visualization and Interactive Visuals in RShiny"
    ]
  },
  {
    "objectID": "lessons/03_visuals.html#creating-a-data-table-output",
    "href": "lessons/03_visuals.html#creating-a-data-table-output",
    "title": "Visualization and Interactive Visuals in RShiny",
    "section": "Creating a data table output",
    "text": "Creating a data table output\nShiny has some native data table functions, however using the DT package is recommended as it supports additional data table features. When you load DT it will mask the base Shiny functions dataTableOutput() with DTOutput() and renderDataTable() with renderDT(). In order to use the DT package, we will need to load it with:\n\nlibrary(DT)\n\nTo render a data table on the UI side you would use:\n\n# DO NOT RUN\nDTOutput(outputID = \"outputID\")\n\nOn the server side you would use:\n\n# DO NOT RUN\noutput$&lt;outputID&gt; &lt;- renderDT({\n    &lt;insert_dataframe&gt;\n  })\n\nLet’s use the built-in dataset mtcars to visualize an example of a data table within a Shiny app.\n\n# User interface\nui &lt;- fluidPage(\n    # Checkbox group to select which columns we would like to see in the data table\n    checkboxGroupInput(inputId = \"column_input\", \n                       label = \"Select columns\", \n                       choices = colnames(mtcars), \n                       inline = TRUE),\n    # The output table\n    DTOutput(\"table\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n    # Render the selected columns from mtcars as a data table\n    output$table &lt;- renderDT({\n        mtcars[,input$column_input, drop = FALSE]\n    })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\nOn the UI side:\n\nWe are using the input function described earlier checkboxGroupInput(), which will allow users to select which columns to display in the table.\nWe are using the DTOutput() funtion with “table” as the ID to correspond with the output object in the server side code\n\nOn the server side:\n\nWe use renderDT() and providing the mtcars dataframe, while using square brackets to subset the columns selected.\n\nThis will visualize in the app as:",
    "crumbs": [
      "Day 1:",
      "Visualization and Interactive Visuals in RShiny"
    ]
  },
  {
    "objectID": "lessons/03_visuals.html#creating-a-plot",
    "href": "lessons/03_visuals.html#creating-a-plot",
    "title": "Visualization and Interactive Visuals in RShiny",
    "section": "Creating a plot",
    "text": "Creating a plot\nCreating plots is an essential skill for being able to create apps in Shiny, and it is exciting because there are so many ways in which you can enhance the visualization. Let’s begin with first demonstrating static plots using the mtcars dataset again. We will be using ggplot2, which is part of the tidyverse package, so we will need to load tidyverse:\n\nlibrary(tidyverse)\n\nThe syntax for implementing plots is:\nOn the UI side:\n\n# DO NOT RUN\nplotOutput(outputId = \"&lt;outputID&gt;\")\n\nOn the server side:\n\n# DO NOT RUN\noutput$&lt;outputID&gt; &lt;- renderPlot({\n    &lt;insert_plot_creation&gt;\n})\n\nIn the example below we are using the selectInput() function to allow users to select which columns to display on the x-axis and y-axis. The choices given are the column names of the dataframe.\nOn the server side, we place ggplot2 code inside the renderPlot() function, specifying what type of plot we want to draw. The aes_string() function allows us to provide information stored in the input object as the x and y values.\n\n# User Interface\nui &lt;- fluidPage(\n    # Dropdown menu to select which column will be used for the x-axis\n    selectInput(inputId = \"x_axis_input\",\n                label = \"Select x-axis\",\n                choices = colnames(mtcars)),\n    # Dropdown menu to select which column will be used for the y-axis\n    selectInput(inputId = \"y_axis_input\",\n                label = \"Select y-axis\",\n                choices = colnames(mtcars),\n                selected = \"disp\"),\n    # The output plot\n    plotOutput(outputId = \"plot\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n    # Render the scatter plot\n    output$plot &lt;- renderPlot({\n        # Scatter plot creation\n        # Importantly, we need to use aes_string() instead of aes() when the information is stored in an input object\n        ggplot(mtcars) +\n            geom_point(aes_string(x = input$x_axis_input, y = input$y_axis_input))\n    })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\nNote\n\n\n\nIn this lesson, we are using the package ggplot2 to create our visualizations, but plots used in Shiny can also be made using the base R graphics or any other packages.\n\n\nThis sample code would look like:\n\n\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nModify the above app to creates a boxplot with the number of cylinders (cyl in the mtcars dataset) fixed on the x-axis and then allows the user to select the metric to visualize on the y-axis from a selectInput() menu.\nHint: You will need to set x = \"factor(cyl)\" in order for the aes_string() function to treat cyl as a column coming from the mtcars dataset rather than looking for a variable in your R environment called cyl.",
    "crumbs": [
      "Day 1:",
      "Visualization and Interactive Visuals in RShiny"
    ]
  },
  {
    "objectID": "lessons/03_visuals.html#interacting-with-plots",
    "href": "lessons/03_visuals.html#interacting-with-plots",
    "title": "Visualization and Interactive Visuals in RShiny",
    "section": "Interacting with plots",
    "text": "Interacting with plots\nWhile the above plot was interesting for being able to select various metrics to plot, it lacked an ability to interact with the actual data points on the graph. For example, if we saw an outlier, how could we try to identify the specific data point. In the section below we will discuss methods that we can use to actually interact with the data points on our plots.\n\nClicking\nThe first way that we can interact with a plot is by clicking a point on the plot. The syntax for this is a bit interesting because it has an input buried within an Output function.\nOn the UI side:\n\n# DO NOT RUN\nplotOutput(outputId = \"plot\", \n           click = \"&lt;plot_clickID&gt;\")\n\nThe click = \"&lt;plot_clickID&gt;\" argument allows for an input from the click action.\n\n\n\n\n\n\nNote\n\n\n\nInstead of click = \"&lt;plot_clickID&gt;\", we could use click = clickOpts(\"&lt;plot_clickID&gt;\") and this will allow us more options on our clicking.\n\n\nOn the server side, we have a few new functions as well:\n\n# DO NOT RUN\n  output$table &lt;- renderDT({\n    nearPoints(&lt;dataframe_used_in_plotting&gt;, input$&lt;plot_clickID&gt;)\n  })\n\nThe nearPoints() function creates a data frame of points near where the cursor clicked on the plot. You can adjust how close (in pixels) you’d like the threshold to be such that when a click is made on the plot which nearby points would register as the selected data point. An example app of this is provided below:\n\n# User Interface\nui &lt;- fluidPage(\n    # Plot the output with an interactive clicking argument\n    plotOutput(outputId = \"plot\", \n               click = \"plot_click\"),\n    # The output table\n    DTOutput(outputId = \"table\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n    # Render a plot from the built-in mtcars dataset\n    output$plot &lt;- renderPlot(\n        ggplot(mtcars) +\n            geom_point(aes(x = mpg, y = disp))\n    )\n    # Render a table from points near to where the click on the plot came from\n    output$table &lt;- renderDT({\n        nearPoints(mtcars, input$plot_click)\n    })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\nThis app would look like:\n\n\n\n\n\n\nHover\nInstead of clicking on points in your plot, you can instead hover over them and identify more information. In order to do this, we need to tweak the UI side of the app.\nOn the UI side:\n\n# DO NOT RUN\nplotOutput(outputId = \"plot\", \n           hover = hoverOpts(id = \"&lt;plot_hoverID&gt;\", \n                             delay = 25))\n\nIn this case, the hover argument is replacing the click argument that we used in the previous example. However, now we are actually utilizing an option (delay = 25) within the [click/hover/brush]Opt()family of functions to reduce the delay in milliseconds before a hover is registered by Shiny. The default is 300ms, which feels a bit unresponsive, so we have reduced it for a more “live” feeling.\nAn example of this code is below:\n\n# User Interface\nui &lt;- fluidPage(\n    # Plot the output with an interactive clicking argument\n    plotOutput(outputId = \"plot\",\n               hover = hoverOpts(id = \"plot_hover\",\n                                 delay = 25)),\n    # The output table\n    DTOutput(outputId = \"table\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n     # Render a plot from the built-in mtcars dataset\n    output$plot &lt;- renderPlot(\n        ggplot(mtcars) +\n            geom_point(aes(x = mpg, y = disp))\n    )\n    # Render a table from points near to where the mouse is hovering on the plot \n    output$table &lt;- renderDT({\n        nearPoints(mtcars, input$plot_hover)\n    })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\nThis app would look like:\n\n\n\n\n\n\nBrush\nThe last way that you can make your plots interactive is with brushing. Perhaps you notice a cluster of points in one part of your scatter plot that you’d like to investigate further. Brushing allows you to use a rectangle to select the points that you would like to interact with. We need a make a few changes to our UI to accommodate brushing:\nOn the UI side:\n\n# DO NOT RUN\nplotOutput(outputId = \"plot\", \n           brush = \"&lt;plot_brushID&gt;\")\n\nWe can change brush = \"&lt;plot_brushID&gt;\" to brush = brushOpt(id = \"&lt;plot_brushID&gt;\"), which will give us access to a few more arguments in the table below:\n\n\n\n\n\n\n\n\nArgument\nDescription\nExample\n\n\n\n\nstroke\nChanges the color of the outline of the rectangle\nstroke = \"orange\"\n\n\nfill\nChanges the color of the fill of the rectangle\nfill = \"pink\"\n\n\nopacity\nChanges the opacity of the rectangle (Scale from 0 to 1)\nopacity = 0.8\n\n\nresetOnNew\nRemoves the current brushed area when a new plot is created (Default is FALSE)\nresetOnNew = TRUE\n\n\n\nOn the server side we need to use:\n\n# DO NOT RUN\n  output$table &lt;- renderDT({\n    brushedPoints(&lt;dataframe_used_in_plotting&gt;, input$&lt;plot_brushID&gt;)\n  })\n\nThe brushedPoints() function works similarly to the nearPoints() function. It gathers the points within the rectangle and outputs their information to a data frame.\nAn example code using brushing looks like:\n\n# User Interface\nui &lt;- fluidPage(\n    #  Plot the output with an interactive brushing argument\n    plotOutput(outputId = \"plot\",\n               brush = \"plot_brush\"),\n    # The output table\n    DTOutput(outputId = \"table\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n    # Render a plot from the built-in mtcars dataset\n    output$plot &lt;- renderPlot(\n        ggplot(mtcars) +\n            geom_point(aes(x = mpg, y = disp))\n    )\n    # Render a table from points within the rectangle created by clicking and dragging over the plot\n    output$table &lt;- renderDT({\n        brushedPoints(mtcars, input$plot_brush)\n    })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\nThis app would look like:\n\n\n\n\n\n\n\n\n\n\nExercise 3\n\n\n\nEdit the above app using brushOpts() so that the fill of the brushed area is crimson (#A51C30), the border of the burshed area is blue (#3E6F7D) and set the opacity of the brushed area is 0.7.\n\n\nNow you have learned how to make your plots interactive!\n\nNext Lesson &gt;&gt;\nBack to Schedule\n\nThis lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.",
    "crumbs": [
      "Day 1:",
      "Visualization and Interactive Visuals in RShiny"
    ]
  },
  {
    "objectID": "lessons/07_hosting.html",
    "href": "lessons/07_hosting.html",
    "title": "Hosting Options for RShiny Apps",
    "section": "",
    "text": "In this lesson, you will:\n\nDescribe Shiny app hosting options",
    "crumbs": [
      "Day 2:",
      "Hosting Options for RShiny Apps"
    ]
  },
  {
    "objectID": "lessons/07_hosting.html#local-usage",
    "href": "lessons/07_hosting.html#local-usage",
    "title": "Hosting Options for RShiny Apps",
    "section": "Local usage",
    "text": "Local usage\nOne option for distributing your app is for it to be run on people’s own computers (locally). If your app is small-scale, this might be a reasonable solution in order to escape the fees associated with running a server to host your app, since this can be done for free. However, one issue with this approach is that it is sensitive to version issues. If a developer develops their app with a certain version of a given package and the user is using a different version, there could be version incapabilities. For this reason alone, sharing apps to be run locally is not considered a great practice.",
    "crumbs": [
      "Day 2:",
      "Hosting Options for RShiny Apps"
    ]
  },
  {
    "objectID": "lessons/07_hosting.html#server-hosting",
    "href": "lessons/07_hosting.html#server-hosting",
    "title": "Hosting Options for RShiny Apps",
    "section": "Server Hosting",
    "text": "Server Hosting\nAs we previously mentioned, the most common way for apps to hosted is via servers. One nice aspect of hosting an app within a server is that the version concerns of running an app locally disappears because the developer’s versions of the loaded packages are the ones that are used on the server. There are two ways that you might choose to host your apps on a server:\n\nPosit Connect / HMS Research Data Visualization Platform (RDVP)\nOne option for hosting your Shiny apps is to use Posit Connect, which your institution may have an account for. HMS has made a pilot for Posit Connect availible to HMS Quad-based faculty, staff, and students through the HMS Research Data Visualization Platform. Unfortunately, HSDM, HSPH, hospital affiliates, and hospital-based labs are not eligible. Users who use this option have access to an unlimited number of apps and computational hours for the duration of the pilot at no cost. This is the likely best option for people who are eligible. Uploading apps through this platform has a few advantages:\n\nUploading apps is simple\nIt allows you to control access to who can see and use your app. You can let anyone use it, require a login or only invite certain people to be able to use it\nYou can give it a custom URL\n\n\n\nShinyapps.io\nIf you aren’t eligible for Posit Connect or the HMS Research Data Visualization Platform then Shinyapps.io is a platform that is run by Posit for hosting Shiny apps and it is likely your next best choice. It has several different levels of access. Its lowest level of access is free and allows the developer to upload up to 5 apps and have 25 hours of computing per month. This level is recommended if you are new to the Shiny world. It allows you host a few apps and play around with them a bit. However, you can quickly go through the 25 hours of computational resources and it won’t be too hard to create more than 5 apps. After the free level, they have higher levels of service that provide developers with more computational hours and higher, or even no, limits on the number of apps. Higher levels also come with more customer services options as well. Pricing information can be found here.",
    "crumbs": [
      "Day 2:",
      "Hosting Options for RShiny Apps"
    ]
  },
  {
    "objectID": "lessons/07_hosting.html#serverless-with-shinylive",
    "href": "lessons/07_hosting.html#serverless-with-shinylive",
    "title": "Hosting Options for RShiny Apps",
    "section": "Serverless with Shinylive",
    "text": "Serverless with Shinylive\nThe last option for hosting is to host your app online on a site like GitHub Pages in a serverless manner. This can work because at the heart of R, it uses C/C++ and modern web browsers can interpret C/C++ code. While there are some limitations to this approach, what it means is that you can host the code for your Shiny app on a website and it is interpretted locally in the user’s web browser. To the user it feels like a traditional, server-hosted app, but under the hood it is actually being run from their own web browser. Due to it being running locally from the user’s web browser, the user is limited by their local memory constraints. The image below contrasts the more traditional server-hosted approach with this server-less shinylive approach:\n\n\n\nImage credit: Joe Cheng “Running Shiny without a server”\nFull documentation for how to host your app using shinylive can be found here and an example of a shinylive app hosted on our GitHub can be found here.\n\nNext Lesson &gt;&gt;\nBack to Schedule\n\nThis lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.",
    "crumbs": [
      "Day 2:",
      "Hosting Options for RShiny Apps"
    ]
  },
  {
    "objectID": "lessons/Aside_advanced_inputs.html",
    "href": "lessons/Aside_advanced_inputs.html",
    "title": "Advanced Inputs",
    "section": "",
    "text": "Previously, we have seen the case of input being used to directly create outputs. However, there is third tool in the Shiny toolkit and it is called reactive expressions. Reactive expressions are useful because they take inputs and produce outputs and they cache, or store, their output. This can be very useful for three reasons:\n\nWhen a step is present multiple times in your code and this step that is either computationally intensive or requires interacting with outside databases, Shiny will only need to carry out the task once rather than each time the process is called since the output will be cached for future uses\nIt makes your code cleaner because you only need to maintain the code for a repetitive step in a single place\nThey are needed to use action buttons (discussed in the next section)\n\nBelow we see relationship between input and output that we have seen up to this point:\n\n\n\nAs we see once we add a reactive expression, it functions as a intermediary between inputs and outputs.\n\n\n\nWhen we use a reactive expression, we will wrap it within a reactive() function. We will use a reactive() function in the next section when we use an action button.\n\nNote: You can also have multiple reactive expressions that connect to each other in between inputs and outputs."
  },
  {
    "objectID": "lessons/Aside_advanced_inputs.html#reactive-expressions",
    "href": "lessons/Aside_advanced_inputs.html#reactive-expressions",
    "title": "Advanced Inputs",
    "section": "",
    "text": "Previously, we have seen the case of input being used to directly create outputs. However, there is third tool in the Shiny toolkit and it is called reactive expressions. Reactive expressions are useful because they take inputs and produce outputs and they cache, or store, their output. This can be very useful for three reasons:\n\nWhen a step is present multiple times in your code and this step that is either computationally intensive or requires interacting with outside databases, Shiny will only need to carry out the task once rather than each time the process is called since the output will be cached for future uses\nIt makes your code cleaner because you only need to maintain the code for a repetitive step in a single place\nThey are needed to use action buttons (discussed in the next section)\n\nBelow we see relationship between input and output that we have seen up to this point:\n\n\n\nAs we see once we add a reactive expression, it functions as a intermediary between inputs and outputs.\n\n\n\nWhen we use a reactive expression, we will wrap it within a reactive() function. We will use a reactive() function in the next section when we use an action button.\n\nNote: You can also have multiple reactive expressions that connect to each other in between inputs and outputs."
  },
  {
    "objectID": "lessons/Aside_advanced_inputs.html#action-buttons",
    "href": "lessons/Aside_advanced_inputs.html#action-buttons",
    "title": "Advanced Inputs",
    "section": "Action buttons",
    "text": "Action buttons\nAction buttons allow the user to tell Shiny to carry out a given function. This can be helpful when you have a computationally heavy task where you don’t want R to be trying to carry out the computation for each input value as you drag a a slider across its scale. Rather you’d only like for outputs to be computed when you have all of your input parameters set. The syntax for using an action button looks like:\nOn the UI side:\nactionButton(\"inputID\", \"Label\")\nOn the Server side:\nreactive_expression_with_action_button &lt;- bindEvent(reactive(\n    &lt;reactive_expression&gt;\n  ), input$&lt;action_button_inputID&gt;)\nThe actionButton(\"inputID\", \"Label\") line creates our action button in the UI, while bindEvent(reactive(&lt;reactive_expression&gt;), input$&lt;action_button_inputID&gt;) wraps a reactive expression within the bindEvent() function on the server side. Alternatively, you may see in other’s code using a pipe (from the tidyverse package), but this is equivalent code to what is listed above:\nOn the UI side:\nactionButton(\"inputID\", \"Label\")\nOn the server side:\nreactive_expression_with_action_button &lt;- reactive(\n    &lt;reactive_expression&gt;\n  ) &gt;%&gt;\n  bindEvent(input$&lt;action_button_inputID&gt;)\nBelow is some example code on how we could implement this:\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  sliderInput(\"slider_input_1\", \"Select a number\", value = 5, min = 1, max = 10),\n  sliderInput(\"slider_input_2\", \"Select a number\", value = 5, min = 1, max = 10),\n  actionButton(\"calculate\", \"Multiply!\"),\n  textOutput(\"product\")\n)\n\nserver &lt;- function(input, output) {\n  multiply &lt;- bindEvent(reactive(\n    input$slider_input_1 * input$slider_input_2\n  ), input$calculate)\n  output$product &lt;- renderText({ \n    multiply()\n  })\n}\n\nshinyApp(ui = ui, server = server)\nThis app would visualize like:\n\n\n\n\nA wide variety of action button styles exist by adding the class argument to your actionButton() function. Such as:\nactionButton(\"inputID\", \"Label\", class = \"btn-primary\")\n\n\n\nClas\n\n\nDescription\n\n\nExample Code\n\n\nExample\n\n\n\n\nbtn-primary\n\n\nCreates a dark blue button\n\n\nclass = “btn-primary”\n\n\n\n\n\n\n\n\n\nbtn-default / btn-secondary\n\n\nCreates a white button\n\n\nclass = “btn-default” / class = “btn-secondary”\n\n\n\n\n\n\n\n\n\nbtn-warning\n\n\nCreates an orange button\n\n\nclass = “btn-warning”\n\n\n\n\n\n\n\n\n\nbtn-danger\n\n\nCreates a red button\n\n\nclass = “btn-danger”\n\n\n\n\n\n\n\n\n\nbtn-info\n\n\nCreates a light blue button\n\n\nclass = “btn-info”\n\n\n\n\n\n\n\n\n\nbtn-lg\n\n\nCreates a larger button\n\n\nclass = “btn-lg”\n\n\n\n\n\n\n\n\n\nbtn-sm\n\n\nCreates a smaller button\n\n\nclass = “btn-sm”\n\n\n\n\n\n\n\n\n\nbtn-link\n\n\nCreates a hyperlink-style button\n\n\nclass = “btn-link”\n\n\n\n\n\n\n\n\n\nbtn-block\n\n\nCreates a button the width of the page\n\n\nclass = “btn-block”\n\n\n\n\n\n\n\nNote: You can have multiple classes for a given action button as long as each class is separated by a space. For example, if you wanted a large, dark blue action button that goes across the entire browser, then you could use: class = \"btn-primary btn-lg btn-block\". However, whichever non-white color you put last in your list of classes will be the color of the button.\n\n\nNote: bindEvent() is a newer function and it replaces functions like observeEvent() and eventReactive() when coupled with observe() and reactive() function, respectively. It is recommended to use bindEvent() moving forward as it is more flexible, but you may still run across code that utilizes observeEvent() and eventReactive()."
  },
  {
    "objectID": "lessons/Aside_advanced_inputs.html#isolate",
    "href": "lessons/Aside_advanced_inputs.html#isolate",
    "title": "Advanced Inputs",
    "section": "Isolate",
    "text": "Isolate\nIn Shiny, you may find that you will want to limit the reactivity as we did in the previous example. However, you might want only partial reactivity and this is where the isolate() feature can be quite helpful. You can create a non=-reactive scope around an expression using isolate. The syntax for using isolate() is:\nisolate(&lt;non_reactive_expression&gt;)\nWe can create a similar app to the one above but edit the code to use isolate. In this example, we will see that the first slider is completely reactive, however the second slider is only reacts once the action button has been clicked:\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  sliderInput(\"slider_input_1\", \"Select a number\", value = 5, min = 1, max = 10),\n  sliderInput(\"slider_input_2\", \"Select a number\", value = 5, min = 1, max = 10),\n  actionButton(\"calculate\", \"Multiply!\"),\n  textOutput(\"product\")\n)\n\nserver &lt;- function(input, output) {\n  output$product &lt;- renderText({\n    input$calculate\n    input$slider_input_1 * isolate(input$slider_input_2)\n  })\n}\n\nshinyApp(ui = ui, server = server)\nThis app would look like:\n\n\n\n\n\nNote: If we had used isolate(input$slider_input_1 * input$slider_input_2) instead of input$slider_input_1 * isolate(input$slider_input_2), then this app would function similarly to the app from the previous section since there are now two sliders’ widget inputs are within the isolate() function."
  },
  {
    "objectID": "lessons/Aside_shinylive.html",
    "href": "lessons/Aside_shinylive.html",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "",
    "text": "In this lesson, you will: - Upload an app to GitHub Pages using Shinylive"
  },
  {
    "objectID": "lessons/Aside_shinylive.html#create-an-rstudio-project",
    "href": "lessons/Aside_shinylive.html#create-an-rstudio-project",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "Create an RStudio Project",
    "text": "Create an RStudio Project\nThe first step in the process is to create an RStudio project. In order to do this:\n\nGo to your RStudio toolbar and select “File” and then select “New Project”\nA pop-up window should appear where you can select “New Directory” and the window should progress to a allow you to choose “Shiny Application”. One benefit of selecting Shiny Application here is that it will automatically create an R script called “app.R”.\nEnter the name of your RStudio project, in this case we are going to call ours “mtcars_demo”\n(Optional) You can select where you would like this project to be saved to by clicking the “Browse…”. However, we are happy saving it to our Desktop.\nClick “Create Project”\n\nThese steps are shown in the GIF below:"
  },
  {
    "objectID": "lessons/Aside_shinylive.html#make-the-app",
    "href": "lessons/Aside_shinylive.html#make-the-app",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "Make the app",
    "text": "Make the app\nThe next step in this process is likely the longest step because you now need to make your app! However, we are going to take a shortcut here and use an app that we have already created for this demonstration.\n\nHighlight and delete the default app that came along with create your Shiny application RStudio project\nCopy the RShiny App below by highlighting it and right-clicking the highliughted text and selecting “Copy”\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(DT)\n\nui &lt;- fluidPage(\n  plotOutput(\"plot\", brush = \"plot_brush\"),\n  DTOutput(\"table\")\n)\n\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot(\n    ggplot(mtcars) +\n      geom_point(aes(x = mpg, y = disp))\n  )\n  output$table &lt;- renderDT({\n    brushedPoints(mtcars, input$plot_brush)\n  })\n}\n\nshinyApp(ui = ui, server = server)\n\nRight-click the script editor panel in your RStudio project and select “Paste”\nSave your app by left-clicking on the “Save” icon in RStudio\n\nThese steps are shown in the GIF below:"
  },
  {
    "objectID": "lessons/Aside_shinylive.html#create-docs-and-export",
    "href": "lessons/Aside_shinylive.html#create-docs-and-export",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "Create docs and export",
    "text": "Create docs and export\nIn order for GitHub Pages to be able to render your Shiny app, you will need to have a specifically named directory called “docs”, which will hold the files output from Shinylive.\n\nClick the “Create a new folder” icon in RStudio\nNamed the new directory “docs”\nWithin the console type the following command:\n\nshinylive::export(appdir = \"../mtcars_demo/\", destdir = \"docs\")\nThis command uses shinylive to export your app found in the app directory (appdir in the command) and direct the output (destdir) into our newly created docs directory.\nThese steps are shown in the GIF below:\n\n\n\n\nNote: The following command will also work:\nshinylive::export(appdir = \".\", destdir = \"docs\")\nHowever, we opted not to use this command in this demo so it would be a bit more clear what the appdir argument was taking in. As a result, we used a relative path to go up a directory then come back down into our current directory. However, for your own work you may opt for this alternative method of directly calling the current directory."
  },
  {
    "objectID": "lessons/Aside_shinylive.html#view-with-httpuv-optional-but-strongly-encouraged",
    "href": "lessons/Aside_shinylive.html#view-with-httpuv-optional-but-strongly-encouraged",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "View with httpuv (Optional; but strongly encouraged)",
    "text": "View with httpuv (Optional; but strongly encouraged)\nOnce you have created your app with shinylive you will likely want to inspect your app locally to be sure that it is how you want it. This is an optional step, but we recommend visualizing your app at this point as a check to make sure the app was rendered correctly. However, one issue with visualizing your app at this point is that it can’t be visualized through tradional methods of looking at your app. You will instead need to emulate the static webpage and visualize it in there. The httpuv package allows you to visualize static webpages in R.\n\nIn the console enter:\n\nhttpuv::runStaticServer(\"docs/\", port = 8008)\n\nInspect your app within your browser to make sure that it is working correctly\nLeft-click on the stop sign above your R console to stop the app\n\nThese steps are shown in the GIF below:"
  },
  {
    "objectID": "lessons/Aside_shinylive.html#make-github-repository",
    "href": "lessons/Aside_shinylive.html#make-github-repository",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "Make GitHub Repository",
    "text": "Make GitHub Repository\nNow that we have made the app and prepped it for being on GitHub, we now need to create a GitHub repository ready to hold our app.\n\nNavigate to your GitHub page\nScroll down to the green “New” button to create a new repository on GitHub\nName your repository in the box underneath “Repsitory name”. We named our app shinylive_app and this will be used in the app URL when we are finished\n(Optional) Include a description of your app\nSelect that you would like this repository to be a “Public” repository rather than a “Private” repository\n(Optional) You can check the text box next to “Add a README file” if you would like to have a README file automaically created with your repository\nLeft-click “Create Repository” at the bottom of the webpage\n\nThese steps are shown in the GIF below:"
  },
  {
    "objectID": "lessons/Aside_shinylive.html#manage-github-pages-settings",
    "href": "lessons/Aside_shinylive.html#manage-github-pages-settings",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "Manage GitHub Pages Settings",
    "text": "Manage GitHub Pages Settings\nNow that we have created our GitHub repository, we will need to edit a few of the settings to allow us to have the Shiny app visualized directory.\n\nIn your repository, left-click on the “Settings” tab\nOn the left-hand side of the webpage, you should now be able to select “Pages” from a menu bar\nLeft-click on the “Branch” dropdown menu and select “main”\nLeft-click on the “Folder” dropdown menu that has just appeared next to the “Branch” dropdown menu and select “/docs”. This is why we had to name our destination directory docs when creating it using shinylive\nLeft-click the “Save” button\n(Optional) You can return back to your code tab on GitHub if you wish, we will not need to adjust any further settings\n\nThese steps are shown in the GIF below:"
  },
  {
    "objectID": "lessons/Aside_shinylive.html#clone-your-github-repository",
    "href": "lessons/Aside_shinylive.html#clone-your-github-repository",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "Clone your GitHub Repository",
    "text": "Clone your GitHub Repository\nNow that we add created our GitHub repository and gotten the settings right, we now will need to clone (or copy) our repository to our local computers.\n\nOpen GitHub Desktop\nLeft-click on the “Current Repository” tab on the top left corner of GitHub Desktop\nLeft-click on the dropdown menu currently displaying “Add”\nSelect “Clone Repository…”\nType the repository name that you used when creating your repository into the “Filter your repositories” text box. In our case, we type are typing in “shinylive_app”, but by the time we have typed in “shinylive” there is only one option left.\nMake sure the GitHub repository that you want to clone is highlighted\nLeft-click the blue “Clone” button\n\nThese steps are shown in the GIF below:"
  },
  {
    "objectID": "lessons/Aside_shinylive.html#copy-app-to-your-cloned-github-repository-and-push-to-the-origin",
    "href": "lessons/Aside_shinylive.html#copy-app-to-your-cloned-github-repository-and-push-to-the-origin",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "Copy app to your cloned GitHub Repository and push to the origin",
    "text": "Copy app to your cloned GitHub Repository and push to the origin\nNow that we’ve cloned our GitHub repository locally, we will need to add the “docs” directory from our app’s directory to our cloned GitHub directory.\n\nIn a file browser, right-click on “docs” directory within your app’s directory and select “Copy”\nIn a second file browser open your cloned GitHub repository or by navigating to your cloned GitHub repository in your same file browser, right-click and select “Paste” or “Paste Item”\nIn GitHub Desktop, add a summary for this commit in the “Summary (required)” text box\n(Optional) You can add an optional description for this commit\nLeft-click the blue “Commit to main” button\nAt the top of your GitHub Desktop, left-click the “Push origin” button\n\nThese steps are shown in the GIF below:"
  },
  {
    "objectID": "lessons/Aside_shinylive.html#view-your-app-on-github-pages",
    "href": "lessons/Aside_shinylive.html#view-your-app-on-github-pages",
    "title": "Using Shinylive to host Shiny app on GitHub Pages",
    "section": "View your app on GitHub Pages",
    "text": "View your app on GitHub Pages\nYou have now uploaded your app to GitHub, so we can look at what it\n\nIn your web browser’s URL enter:\n\nhttps://&lt;github_username&gt;.github.io/&lt;app_name&gt;/\nReplace &lt;github_username&gt; with your GitHub username and &lt;app_name&gt; with your app’s name. Your app should appear after taking a moment to load!\nThese steps are shown in the GIF below:\n\n\n\nCongratulations! You have successfully added your app to a GitHub Pages using shinylive! Now you can share your app with your colleagues without the need of having a server to host your app!\nYou can see the app that we created here."
  },
  {
    "objectID": "lessons/Aside_CSS.html",
    "href": "lessons/Aside_CSS.html",
    "title": "Customizing apps with CSS in RShiny",
    "section": "",
    "text": "Next Lesson &gt;&gt;\nBack to Schedule\n\nThis lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited."
  },
  {
    "objectID": "lessons/05_uploading_downloading_data.html",
    "href": "lessons/05_uploading_downloading_data.html",
    "title": "Uploading and dowloading data in RShiny",
    "section": "",
    "text": "In this lesson, you will: - Implement reactive expressions - Learn how to incorporate data into your Shiny app - Add functionality to download table data from Shiny app - Download plots created in Shiny app - Create action buttons for a Shiny app",
    "crumbs": [
      "Day 2:",
      "Uploading and dowloading data in RShiny"
    ]
  },
  {
    "objectID": "lessons/05_uploading_downloading_data.html#learning-objectives",
    "href": "lessons/05_uploading_downloading_data.html#learning-objectives",
    "title": "Uploading and dowloading data in RShiny",
    "section": "",
    "text": "In this lesson, you will: - Implement reactive expressions - Learn how to incorporate data into your Shiny app - Add functionality to download table data from Shiny app - Download plots created in Shiny app - Create action buttons for a Shiny app",
    "crumbs": [
      "Day 2:",
      "Uploading and dowloading data in RShiny"
    ]
  },
  {
    "objectID": "lessons/05_uploading_downloading_data.html#action-buttons",
    "href": "lessons/05_uploading_downloading_data.html#action-buttons",
    "title": "Uploading and dowloading data in RShiny",
    "section": "Action Buttons",
    "text": "Action Buttons\nAction buttons allow the user to tell Shiny when to process data. This can be helpful when you have a computationally heavy task where you don’t want R to be trying to carry out the computation for each input value as you drag a a slider across its scale. Rather you’d only like for outputs to be computed when you have all of your input parameters set. The syntax for using an action button looks like:\nOn the UI side:\nactionButton(\"inputID\", \"Label\")\nOn the Server side:\nreactive_expression_with_action_button &lt;- bindEvent(reactive(\n    &lt;reactive_expression&gt;\n  ), input$&lt;action_button_inputID&gt;)\nThe actionButton(\"inputID\", \"Label\") line creates our action button in the UI, while bindEvent(reactive(&lt;reactive_expression&gt;), input$&lt;action_button_inputID&gt;) wraps a reactive expression within the bindEvent() function on the server side. Alternatively, you may see in others’ code using a pipe (see below), but this is equivalent code to what is listed above:\nOn the UI side:\nactionButton(\"inputID\", \"Label\")\nOn the server side:\nreactive_expression_with_action_button &lt;- reactive(\n    &lt;reactive_expression&gt;\n  ) &gt;%&gt;\n  bindEvent(input$&lt;action_button_inputID&gt;)\nBelow is example code on how we could implement this:\n# User interface\nui &lt;- fluidPage(\n    # Slider for the user to select a number between 1 and 10\n    sliderInput(\"slider_input_1\", \"Select a number\", value = 5, min = 1, max = 10),\n    # Slider for the user to select a number between 1 and 10\n    sliderInput(\"slider_input_2\", \"Select a number\", value = 5, min = 1, max = 10),\n    # Action button to tell Shiny to evaluate the multiplication when it is clicked\n    actionButton(\"calculate\", \"Multiply!\"),\n    # The text output\n    textOutput(\"product\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n    # Create a reactive expression that responds to a mouse clicking the action button\n    multiply &lt;- bindEvent(reactive(\n        input$slider_input_1 * input$slider_input_2\n    ), input$calculate)\n    # Render the reactive expression as text\n    output$product &lt;- renderText({ \n        multiply()\n    })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\nThis app would visualize like:\n\n\n\n\nA wide variety of action button styles exist by adding the class argument to your actionButton() function. Such as:\nactionButton(\"inputID\", \"Label\", class = \"btn-primary\")\n\n\nClick here if you would like to see a table of availible action button styles\n\n\n\n\nClass\n\n\nDescription\n\n\nExample Code\n\n\nExample\n\n\n\n\nbtn-primary\n\n\nCreates a dark blue button\n\n\nclass = “btn-primary”\n\n\n\n\n\n\n\n\n\nbtn-default / btn-secondary\n\n\nCreates a white button\n\n\nclass = “btn-default” / class = “btn-secondary”\n\n\n\n\n\n\n\n\n\nbtn-warning\n\n\nCreates an orange button\n\n\nclass = “btn-warning”\n\n\n\n\n\n\n\n\n\nbtn-danger\n\n\nCreates a red button\n\n\nclass = “btn-danger”\n\n\n\n\n\n\n\n\n\nbtn-info\n\n\nCreates a light blue button\n\n\nclass = “btn-info”\n\n\n\n\n\n\n\n\n\nbtn-lg\n\n\nCreates a larger button\n\n\nclass = “btn-lg”\n\n\n\n\n\n\n\n\n\nbtn-sm\n\n\nCreates a smaller button\n\n\nclass = “btn-sm”\n\n\n\n\n\n\n\n\n\nbtn-link\n\n\nCreates a hyperlink-style button\n\n\nclass = “btn-link”\n\n\n\n\n\n\n\n\n\nbtn-block\n\n\nCreates a button the width of the page\n\n\nclass = “btn-block”\n\n\n\n\n\n\n\n\nNote: You can have multiple classes for a given action button as long as each class is separated by a space. For example, if you wanted a large, dark blue action button that goes across the entire browser, then you could use: class = \"btn-primary btn-lg btn-block\". However, whichever non-white color you put last in your list of classes will be the color of the button.\n\n\nNote: bindEvent() is a newer function and when coupled with observe() and reactive() functions, it replaces observeEvent() and eventReactive() functions, respectively. It is recommended to use bindEvent() moving forward as it is more flexible, but you may still run across code that utilizes observeEvent() and eventReactive().",
    "crumbs": [
      "Day 2:",
      "Uploading and dowloading data in RShiny"
    ]
  },
  {
    "objectID": "lessons/05_uploading_downloading_data.html#isolate",
    "href": "lessons/05_uploading_downloading_data.html#isolate",
    "title": "Uploading and dowloading data in RShiny",
    "section": "Isolate",
    "text": "Isolate\nIn Shiny, you may find that you will want to limit the reactivity. However, you might want only partial reactivity and this is where the isolate() feature can be quite helpful. You can create a non-reactive scope around an expression using isolate. The syntax for using isolate() is:\nisolate(&lt;non_reactive_expression&gt;)\nWe can create a similar app to the one above but edit the code to use isolate. In this example, we will see that the first slider is completely reactive, however the second slider is only reacts once the action button has been clicked:\n# User interface\nui &lt;- fluidPage(\n    # Slider for the user to select a number between 1 and 10\n    sliderInput(\"slider_input_1\", \"Select a number\", value = 5, min = 1, max = 10),\n    # Slider for the user to select a number between 1 and 10\n    sliderInput(\"slider_input_2\", \"Select a number\", value = 5, min = 1, max = 10),\n    # The button that will re-process the calculation containing elements within the isolate function after it has been clicked\n    actionButton(\"calculate\", \"Multiply!\"),\n    # The output text\n    textOutput(\"product\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n    # Renders the text for the product of the values from the two sliders\n    # Note that the first slider is not inside an isolate function and will thus react in real-time, while the second slider is within an isolate function, so it will only be evaluated when the action button has been clicked\n    output$product &lt;- renderText({\n        input$calculate\n        input$slider_input_1 * isolate(input$slider_input_2)\n    })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\nThis app would look like:\n\n\n\n\n\nNote: If we had used isolate(input$slider_input_1 * input$slider_input_2) instead of input$slider_input_1 * isolate(input$slider_input_2), then this app would function similarly to the app from the previous section since there are now two sliders’ widget inputs are within the isolate() function.",
    "crumbs": [
      "Day 2:",
      "Uploading and dowloading data in RShiny"
    ]
  },
  {
    "objectID": "lessons/05_uploading_downloading_data.html#uploading-data",
    "href": "lessons/05_uploading_downloading_data.html#uploading-data",
    "title": "Uploading and dowloading data in RShiny",
    "section": "Uploading data",
    "text": "Uploading data\nOften apps are created such that one can explore their own data in some way. To allows users to upload their own data into the app we use the fileInput() function on the UI side:\nfileInput(\"&lt;input_fileID&gt;\", \"&lt;Text_above_file_upload&gt;\")\nThere are some additional options that you might want to consider when using the fileInput() function.\n\n\n\n\n\n\n\n\nArgument\nDescription\nExample\n\n\n\n\nmultiple\nAllows the user to upload multiple files*\nmultiple = TRUE\n\n\naccept\nLimit the file extensions that can be selected by the user\naccept = \".csv\"\n\n\nplaceholder\nText to be entered as a placeholder instead of the “No file selected” default\nplaceholder = \"Waiting for file selection\"\n\n\nbuttonLabel\nText to be entered onto the upload button instead of “Browse…” default\nbuttonLabel = \"Select File...\"\n\n\n\n* Uploading multiple files can be a bit tricky and is outside of the scope of this workshop, but it can be done.\nOn the server side it would look like:\n  uploaded_file &lt;- reactive({\n    req(input$&lt;input_fileID&gt;)\n    read.table(input$&lt;input_fileID&gt;$datapath)\n  })\n  output$table &lt;- renderDT(\n    uploaded_file()\n  )\nThe first part of this code is creating the reactive expression uploaded_file(). We require that the file exist with req(input$&lt;input_fileID&gt;), otherwise Shiny will return an error until we upload a file. Then we read in the file with a function from the read.table() family of functions.\nThe example app for this would look like:\n# User interface\nui &lt;- fluidPage(\n    # File upload button\n    fileInput(\"input_file\", \"Upload your file\"),\n    # The output table\n    DTOutput(\"table\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n    # Create a reactive expression that requires a file have been uploaded and reads in the CSV file that was uploaded\n    uploaded_file &lt;- reactive({\n        req(input$input_file)\n        read.csv(input$input_file$datapath, header = TRUE, row.names = 1)\n    })\n    # Renders the reactive expression as a table\n    output$table &lt;- renderDT(\n        uploaded_file()\n    )\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\nThis app would look like:",
    "crumbs": [
      "Day 2:",
      "Uploading and dowloading data in RShiny"
    ]
  },
  {
    "objectID": "lessons/05_uploading_downloading_data.html#downloading-analysis",
    "href": "lessons/05_uploading_downloading_data.html#downloading-analysis",
    "title": "Uploading and dowloading data in RShiny",
    "section": "Downloading Analysis",
    "text": "Downloading Analysis\nIn the course of doing your analyses, it is likely that you will get to a point where you want to download data stored in a data frame or a plot that you’ve created. Shiny also provides functionality to do this. When you are interested in downloading data or plots, you are going to want to use the downloadButton() (UI side) and downloadHandler() (server side) functions.\n\nDownloading a Data Frame\nIf you have a data frame that you want to download then the important pieces of syntax are:\nOn the UI side:\ndownloadButton(\"&lt;download_buttonID&gt;\", \"Download the data .csv\")\nThe download button is very similar to the actionButton() function that we’ve recently explored. In fact, it also accepts the class argument(s) similar to the actionButton() function.\nOn the server side:\n  output$&lt;download_buttonID&gt; &lt;- downloadHandler(\n    filename = function() {\n      \"&lt;your_placeholder_filename&gt;.csv\"\n    },\n    content = function(file) {\n      write.csv(&lt;your_data_frame&gt;, file, quote = FALSE)\n    }\n)\nOn the server side, we need to use the downloadHandler() function. The downloadHandler() function has two main arguments:\n\nfilename - This is the default filename that will pop-up when you try to save the file.\ncontent - This is the argument where you write your data frame to a file. In this case, we are writing to a .csv, so we use write.csv(). We are writing it to a temporary object called file that downloadHandler() recognizes as the output from content.\n\nAn example app using this is similar to the brushed points example we used previously:\n# User interface\nui &lt;- fluidPage(\n    #  Plot the output with an interactive brushing argument\n    plotOutput(\"plot\", brush = \"plot_brush\"),\n    # The output table\n    DTOutput(\"table\"),\n    # Download button\n    downloadButton(\"download_button\", \"Download the data .csv\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n    # Render a plot from the built-in mtcars dataset\n    output$plot &lt;- renderPlot(\n        ggplot(mtcars) +\n            geom_point(aes(x = mpg, y = disp))\n    )\n    # Reactive expression to hold the brushed points\n    brushed_points &lt;- reactive(\n        brushedPoints(mtcars, input$plot_brush)\n    )\n    # Render a table from brushed points the reactive expression is caching\n    output$table &lt;- renderDT({\n        brushed_points()\n    })\n    # Download the data\n    output$download_button &lt;- downloadHandler(\n        # The placeholder name for the file will be called mtcars_subset.csv\n        filename = function() {\n            \"mtcars_subset.csv\"\n        },\n        # The content of the file will be the contents of the brushed points reactive expression\n        content = function(file) {\n            write.csv(brushed_points(), file, quote = FALSE)\n        }\n    )\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\nIn the above script, we tweaked our script to allow us to download the table containing the brushed points.\n\nWe added a download button to our UI with downloadButton(\"download_button\", \"Download the data .csv\")\nWe moved our brushedPoints() function out of renderDT() and placed it within a reactive() function since we will be calling it twice, once in the renderDT() function and again when we write our data in the downloadHandler() function\nWithin the downloadHandler() function we provided a filename to use as a placeholder (\"mtcars_subset.csv\") as well as defining the content of our .csv file (write.csv(brushed_points(), file, quote = FALSE))\n\nThis app looks like:\n\n\n\n\n\n\nDownloading a plot\nDownloading a plot is similiar to downloading a table. It also uses the downloadButton() and downloadHandler() functions and the arguments are largely similar. The syntax looks like:\nOn the UI side:\ndownloadButton(\"&lt;download_buttonID&gt;\", \"Download the data .png\")\nOn the server side:\n  output$&lt;download_buttonID&gt; &lt;- downloadHandler(\n    filename = function() {\n      \"&lt;your_placeholder_filename&gt;.png\"\n    },\n    content = function(file) {\n      png(file)\n      print(&lt;your_plot&gt;)\n      dev.off()\n    }\n  )\nWe can modify our first plot app to allow us to download the plot:\n# User Interface\nui &lt;- fluidPage(\n    # Dropdown menu to select the column of data to put on the x-axis\n    selectInput(\"x_axis_input\", \"Select x-axis\", choices = colnames(mtcars)),\n    # Dropdown menu to select the column of data to put on the y-axis\n    selectInput(\"y_axis_input\", \"Select y-axis\", choices = colnames(mtcars), selected = \"disp\"),\n    # The output plot\n    plotOutput(\"plot\"),\n    # Download button\n    downloadButton(\"download_button\", \"Download the data .png\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n    # Reactive expression to hold the scatter plot\n    mtcars_plot &lt;- reactive({\n        ggplot(mtcars) +\n            geom_point(aes_string(x = input$x_axis_input, y = input$y_axis_input))\n    })\n    # Render plot from the reactive expression\n    output$plot &lt;- renderPlot({\n        mtcars_plot()\n    })\n    # Download the data\n    output$download_button &lt;- downloadHandler(\n        # The placeholder name for the file will be called mtcars_plot.png\n        filename = function() {\n            \"mtcars_plot.png\"\n        },\n        # The content of the file will be the contents of the mtcars_plot() reactive expression\n        # Note how we need to encapsulate the plot in png() and dev.off() functions\n        # The syntax also demands that we put print() around our plot\n        content = function(file) {\n            png(file)\n            print(mtcars_plot())\n            dev.off()\n        }\n    )\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\nSome key aspects of this app are: - Similarly to when we downloaded the data frame, we have moved our plot function to be within a reactive() function (called mtcars_plot). - Our renderPlot() function called the mtcars_plot() reactive expression. - We call our downloadHandler() function and provide it a default file name of \"mtcars_plot.png\" and for content, we call it mostly the same way as we would write a plot out in R; calling the png() function, plotting our plot, then closing the device with the dev.off() function. The only thing of note here is that we go need to wrap the mtcars_plot() reactive expression within a print() function.\nThis app looks like:",
    "crumbs": [
      "Day 2:",
      "Uploading and dowloading data in RShiny"
    ]
  },
  {
    "objectID": "lessons/06_layouts.html",
    "href": "lessons/06_layouts.html",
    "title": "Arranging Layouts",
    "section": "",
    "text": "In this lesson, you will: - Implement sidebars into your Shiny app - Create tabsets - Implement different shinythemes",
    "crumbs": [
      "Day 2:",
      "Arranging Layouts"
    ]
  },
  {
    "objectID": "lessons/06_layouts.html#nesting-columns",
    "href": "lessons/06_layouts.html#nesting-columns",
    "title": "Arranging Layouts",
    "section": "Nesting columns",
    "text": "Nesting columns\nYou can also nest fluidRow() functions within the column() function of another fluidRow() function. Once again, the important rule when using fluidRow() is that the sum of the column()’s width value within each fluidRow() sums to 12. Let’s take a look at some example syntax of how this would look:\n  fluidRow(\n    column(&lt;width_of_first_main_column&gt;,\n      fluidRow(\n        column(&lt;width_of_first_subcolumn_of_the_first_main_column&gt;,\n          &lt;objects_in_first_column_first_subcolumn&gt;\n        ),\n        column(&lt;width_of_second_subcolumn_of_the_first_main_column&gt;,\n          &lt;objects_in_first_column_second_subcolumn&gt;\n        )\n      )\n    ),\n    column(&lt;width_of_second_main_column&gt;,\n      &lt;objects_in_second_column&gt;\n    )\n  )\n)\nWe can apply these principles to our app:\nlibrary(shiny)\nlibrary(ggplot2)\n\nui &lt;- fluidPage(\n  titlePanel(\n    h1(\"My iris Shiny App\", align = \"center\")\n  ),\n  fluidRow(\n    column(7,\n      fluidRow(\n        column(6,\n        h3(\"First column: First subcolumn\"),\n        selectInput(\"x_axis_input\", \"Select x-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"))\n        ),\n        column(6,\n        h3(\"First column: Second subcolumn\"),\n        selectInput(\"y_axis_input\", \"Select y-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"))\n        )\n      )\n    ),\n    column(5,\n      h3(\"Second column\"),\n      plotOutput(\"plot\")\n    )\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    ggplot(iris) +\n      geom_point(aes(x = .data[[input$x_axis_input]], y = .data[[input$y_axis_input]]))\n  })\n}\n\nshinyApp(ui = ui, server = server)\nThis app would look like:",
    "crumbs": [
      "Day 2:",
      "Arranging Layouts"
    ]
  },
  {
    "objectID": "lessons/06_layouts.html#multiple-rows",
    "href": "lessons/06_layouts.html#multiple-rows",
    "title": "Arranging Layouts",
    "section": "Multiple Rows",
    "text": "Multiple Rows\nNow that we’ve seen how to make multiple columns, let’s breifly talk about multiple rows. Instead of nesting fluidRow() function within one another, we will treat them like we’ve treated objects that go underneath one another, by putting complete fluidRow() functions underneath each other in out code. An example of this syntax can be seen below:\nfluidRow(\n  column(&lt;width_of_first_column_in_the_first_row&gt;,\n    &lt;objects_in_first_column_first_row&gt;\n  ),\n  column(&lt;width_of_second_column_in_the_first_row&gt;,\n    &lt;objects_in_second_column_first_row&gt;\n  )\n),\nfluidRow(\n  column(&lt;width_of_first_column_in_the_second_row&gt;,\n    &lt;objects_in_first_column_second_row&gt;\n  ),\n  column(&lt;width_of_second_column_in_the_second_row&gt;,\n    &lt;objects_in_second_column_second_row&gt;\n  )\n)\nWe can apply the concept of multiple rows to our app:\nlibrary(shiny)\nlibrary(ggplot2)\n\nui &lt;- fluidPage(\n  titlePanel(\n    h1(\"My iris Shiny App\", align = \"center\")\n  ),\n  fluidRow(\n    column(6,\n      h3(\"First Row: First column\"),\n      selectInput(\"x_axis_input\", \"Select x-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"))\n    ),\n      column(6,\n      h3(\"First Row: Second column\"),\n      selectInput(\"y_axis_input\", \"Select y-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"))\n    )\n  ),\n  fluidRow(\n      h3(\"Second Row\"),\n      plotOutput(\"plot\")\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    ggplot(iris) +\n      geom_point(aes(x = .data[[input$x_axis_input]], y = .data[[input$y_axis_input]]))\n  })\n}\n\nshinyApp(ui = ui, server = server)\nThis app would look like:",
    "crumbs": [
      "Day 2:",
      "Arranging Layouts"
    ]
  },
  {
    "objectID": "lessons/06_layouts.html#thematic-breaks",
    "href": "lessons/06_layouts.html#thematic-breaks",
    "title": "Arranging Layouts",
    "section": "Thematic Breaks",
    "text": "Thematic Breaks\nThematic breaks are a great way to break-up different parts of an app. The function to add a themetic break is also borrowed from HTML and it is called hr(). The syntax for using it is very simple:\nhr()\nIn the previous example, if we wanted to break up the selectInput() functions from the plotOutput() function, then we could add a thematic break like:\nlibrary(shiny)\nlibrary(ggplot2)\n\nui &lt;- fluidPage(\n  titlePanel(\n    h1(\"My iris Shiny App\", align = \"center\")\n  ),\n  fluidRow(\n    column(6,\n           h3(\"First Row: First column\"),\n           selectInput(\"x_axis_input\", \"Select x-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"))\n    ),\n    column(6,\n           h3(\"First Row: Second column\"),\n           selectInput(\"y_axis_input\", \"Select y-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"))\n    )\n  ),\n  hr(),\n  fluidRow(\n    h3(\"Second Row\"),\n    plotOutput(\"plot\")\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    ggplot(iris) +\n      geom_point(aes(x = .data[[input$x_axis_input]], y = .data[[input$y_axis_input]]))\n  })\n}\n\nshinyApp(ui = ui, server = server)\nThis app would now look like:",
    "crumbs": [
      "Day 2:",
      "Arranging Layouts"
    ]
  },
  {
    "objectID": "lessons/06_layouts.html#navigation-bar-menu",
    "href": "lessons/06_layouts.html#navigation-bar-menu",
    "title": "Arranging Layouts",
    "section": "Navigation Bar Menu",
    "text": "Navigation Bar Menu\nWithin the navigaton bar, we can have a dropdown menu that gives us more options in a list. This would be accomplished using the navbarMenu() function, which also utilizes tabPanel() function that navbarPage() uses. The syntax for using a dropdown menu anvigation bar menu is:\nnavbarPage(\"&lt;title_of_navigation_bar&gt;\",\n  navbarMenu(\"&lt;name_for_dropdown_menu&gt;\",\n    tabPanel(\"&lt;title_of_option_1_in_menu&gt;\",\n      &lt;content_of_option_1_in_menu&gt;\n    ),\n    tabPanel(\"&lt;title_of_option_2_in_menu&gt;\",\n      &lt;content_of_option_2_in_menu&gt;\n    )\n  )\n)\nA code example of the navbarMenu() function can be seen below:\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(DT)\n\nui &lt;- fluidPage(\n  navbarPage(\"My iris dataset\",\n    tabPanel(\"Inputs\",\n      selectInput(\"x_axis_input\", \"Select x-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\")),\n      selectInput(\"y_axis_input\", \"Select y-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"))\n    ),\n    navbarMenu(\"Outputs\",\n      tabPanel(\"Plot\",\n        plotOutput(\"plot\")\n      ),\n      tabPanel(\"Table\",\n        DTOutput(\"table\")   \n      )\n    )\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    ggplot(iris) +\n      geom_point(aes(x = .data[[input$x_axis_input]], y = .data[[input$y_axis_input]]))\n  })\n  output$table &lt;- renderDT({\n    iris[,c(input$x_axis_input, input$y_axis_input), drop = FALSE]\n  })\n}\n\nshinyApp(ui = ui, server = server)\nThis app would look like:",
    "crumbs": [
      "Day 2:",
      "Arranging Layouts"
    ]
  },
  {
    "objectID": "lessons/06_layouts.html#navigation-list",
    "href": "lessons/06_layouts.html#navigation-list",
    "title": "Arranging Layouts",
    "section": "Navigation List",
    "text": "Navigation List\nIn place of of a navigation bar along the top of the window, you can also opt for a list down the side of the app using the navlistPanel() in place of the navbarPage() function. The syntax for using this style of list looks like:\nnavlistPanel(\"&lt;title_of_navigation_list&gt;\",\n  tabPanel(\"&lt;title_of_tab_1&gt;\",\n    &lt;content_of_tab_1&gt;\n  ),\n  tabPanel(\"&lt;title_of_tab_2&gt;\",\n    &lt;content_of_tab_2&gt;\n  ),\n)\nAn example for this code is below:\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(DT)\n\nui &lt;- fluidPage(\n  navlistPanel(\"My iris dataset\",\n             tabPanel(\"Inputs\",\n                      selectInput(\"x_axis_input\", \"Select x-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\")),\n                      selectInput(\"y_axis_input\", \"Select y-axis\", choices = c(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\"))\n             ),\n             navbarMenu(\"Outputs\",\n                        tabPanel(\"Plot\",\n                                 plotOutput(\"plot\")\n                        ),\n                        tabPanel(\"Table\",\n                                 DTOutput(\"table\")   \n                        )\n             )\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    ggplot(iris) +\n      geom_point(aes(x = .data[[input$x_axis_input]], y = .data[[input$y_axis_input]]))\n  })\n  output$table &lt;- renderDT({\n    iris[,c(input$x_axis_input, input$y_axis_input), drop = FALSE]\n  })\n}\n\nshinyApp(ui = ui, server = server)\nThis would create an app that looks like:\n\n\n\n\n\nNote that the navbarMenu() function also works within navlistPanel() just like it works within navbarPage().",
    "crumbs": [
      "Day 2:",
      "Arranging Layouts"
    ]
  },
  {
    "objectID": "lessons/08_layout_practical.html",
    "href": "lessons/08_layout_practical.html",
    "title": "Practical Exercise",
    "section": "",
    "text": "Back to Schedule\n\nThis lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.",
    "crumbs": [
      "Day 2:",
      "Practical Exercise"
    ]
  },
  {
    "objectID": "lessons/04_input_practical.html",
    "href": "lessons/04_input_practical.html",
    "title": "Practical Exercise",
    "section": "",
    "text": "Something like grab columns from the iris dataset and plot it or something, but make sure it is different enough from the visualization lessons.\n\nNext Lesson &gt;&gt;\nBack to Schedule\n\nThis lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.",
    "crumbs": [
      "Day 1:",
      "Practical Exercise"
    ]
  },
  {
    "objectID": "lessons/self-learning.html#on-your-desktop",
    "href": "lessons/self-learning.html#on-your-desktop",
    "title": "",
    "section": "On your desktop",
    "text": "On your desktop\n\nR\nRStudio\nThe listed R packages"
  },
  {
    "objectID": "lessons/self-learning.html#interesting-input-widgets",
    "href": "lessons/self-learning.html#interesting-input-widgets",
    "title": "",
    "section": "Interesting Input Widgets",
    "text": "Interesting Input Widgets\n\nPicker\nshinyChakraSlider\n\n\nThese materials have been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited."
  },
  {
    "objectID": "lessons/01_syntax_and_structure.html#user-interface",
    "href": "lessons/01_syntax_and_structure.html#user-interface",
    "title": "Structure and Syntax in RShiny",
    "section": "User Interface",
    "text": "User Interface\nLet’s go line-by line and breakdown the code for the UI:\n\n# DO NOT RUN\n# User Interface\nui &lt;- fluidPage(\n  ...\n)\n\nThe fluidPage() function is a common function used to develop UI layouts in Shiny and it is being assigned to the object ui. It is considered “fluid” because the page width adjust automatically. There is an alternative function for creating UI layouts called fixedPage(), which is similar to fluidPage(), except it used a fixed page width rather than a fluid page width. Most apps use a fluid approach in practice, so we will be using fluidPage().\n\n# DO NOT RUN\n# The input text box\ntextInput(inputId = \"input_text\",\n          label = \"My input text\")\n\nThere are many types of input and output types in RShiny, we will discuss these types at length in the upcoming lessons. In this example, we are creating a text input using the textInput() function. There are two arguments:\n\nThe first argument is the variable name for the user input to be stored to.\nThe second argument is a character string representing the text which will be placed above the input text box.\n\nBecause this is the first line of code for the user interface, this input text box will appear at the top of the app.\n\n# DO NOT RUN\n# The output text\ntextOutput(outputId = \"output_text\")\n\nThe textOuput() function is telling the UI where to put the output text after it has been rendered by the server. We haven’t seen where the variable output_text is created yet, but we will see it in the server section below.\nImportantly, each line at the same scope in the UI is separated by a comma.\n\n\n\n\n\n\nNote\n\n\n\nYou’ll frequently see Shiny functions written with just the arguments, like textInput(\"input_text\", \"My input text\") or textOutput(\"output_text\"). In this tutorial, we’ll include explicit argument names (e.g., inputId =, label = and outputId =) to help make the code more readable and easier to follow as you’re learning.",
    "crumbs": [
      "Day 1:",
      "Structure and Syntax in RShiny"
    ]
  },
  {
    "objectID": "lessons/01_syntax_and_structure.html#server",
    "href": "lessons/01_syntax_and_structure.html#server",
    "title": "Structure and Syntax in RShiny",
    "section": "Server",
    "text": "Server\nNow let’s investigate the server side of the app:\n\n# DO NOT RUN\n# Server\nserver &lt;- function(input, output){\n  ...\n  })\n\nThe server function is created with the variables input and output to hold the input and output of the app. Inside the function we place the following code:\n\n# DO NOT RUN \n    # Render the text\n    output$output_text &lt;- renderText({\n        input$input_text\n    })\n\nHere, we are using the renderText() function to take the object from textInput() render it as output. We then take that rendering and assign it to output$output_text which ties back to the textOutput() function we had in the UI section of code.\n\n\n\n\n\n\nNote\n\n\n\nThe render[Type]() family of functions are specific to the type of [type]Output(). We will talk about this more in upcoming lessons.",
    "crumbs": [
      "Day 1:",
      "Structure and Syntax in RShiny"
    ]
  },
  {
    "objectID": "lessons/01_syntax_and_structure-Answer_Key.html",
    "href": "lessons/01_syntax_and_structure-Answer_Key.html",
    "title": "Structure and Syntax in RShiny - Answer Key",
    "section": "",
    "text": "Exercise 1\nAfter browsing the gallery of Shiny Apps that have been made by others, what apps do you think you could develop to analyze your own data?\nThis is a very open-ended question, but some potential ideas could be:\n\nRunning QC analyses on a dataset where you are determining thresholds\nReading in standardized data to create a report\nCreating a toy example for how a statistical approach works\n\n\n\nExercise 2\n\nName the three parts of an RShiny app and give a brief explanation of each part.\nIn the basic app that we created in this lesson:\n\n\n# User Interface\nui &lt;- fluidPage(\n    # The input text box\n    textInput(inputId = \"input_text\", \n              label = \"My input text\"),\n    # The output text\n    textOutput(outputId = \"output_text\")\n)\n\n# Server\nserver &lt;- function(input, output){\n    # Render the text\n    output$output_text &lt;- renderText({\n        input$input_text\n    })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\nDescribe what information input$input_text and output$output_text holds.\ninput$input_text is a character string that holds the text entered by the user in the textbox of the RShiny app and output$output_text holds the text that will be returned to the UI as output, after it is rendered by the server.\n\n\n\n\n\n\nReuseCC-BY-4.0"
  },
  {
    "objectID": "lessons/01_syntax_and_structure-Answer_key.html",
    "href": "lessons/01_syntax_and_structure-Answer_key.html",
    "title": "Structure and Syntax in RShiny - Answer Key",
    "section": "",
    "text": "Exercise 1\nAfter browsing the gallery of Shiny Apps that have been made by others, what apps do you think you could develop to analyze your own data?\nThis is a very open-ended question, but some potential ideas could be:\n\nRunning QC analyses on a dataset where you are determining thresholds\nReading in standardized data to create a report\nCreating a toy example for how a statistical approach works\n\n\n\nExercise 2\n\nName the three parts of an RShiny app and give a brief explanation of each part.\nIn the basic app that we created in this lesson:\n\n\n# User Interface\nui &lt;- fluidPage(\n    # The input text box\n    textInput(inputId = \"input_text\", \n              label = \"My input text\"),\n    # The output text\n    textOutput(outputId = \"output_text\")\n)\n\n# Server\nserver &lt;- function(input, output){\n    # Render the text\n    output$output_text &lt;- renderText({\n        input$input_text\n    })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\nDescribe what information input$input_text and output$output_text holds.\ninput$input_text is a character string that holds the text entered by the user in the textbox of the RShiny app and output$output_text holds the text that will be returned to the UI as output, after it is rendered by the server.\n\n\n\n\n\n\nReuseCC-BY-4.0"
  },
  {
    "objectID": "lessons/02_inputs-Answer_key.html",
    "href": "lessons/02_inputs-Answer_key.html",
    "title": "Input functions in RShiny - Answer Key",
    "section": "",
    "text": "Exercise 1\nUse the input widgets presented above and the associate code to create your own RShiny app! It will take numeric input from a select dropdown menu, radio button and slider and then multiply the values together and return the product. Let’s break this down into a few parts:\n\nCreate the user interface for the app that allows the user to select the values 1-3 from a selectInput() function, the values 4-6 from a radioButtons() function and the values 7-9 from a sliderInput().\n\n\n# User Interface\nui &lt;- fluidPage(\n  # Select a number between 1 and 3 from a select dropdown menu\n  selectInput(inputId = \"selected_number\",\n              label = \"Pick a number\",\n              choices = c(1, 2, 3)),\n  # Select a number between 4 and 6 from radio buttons\n  radioButtons(inputId = \"radio_number\",\n               label = \"Pick a number\",\n               choices = c(4, 5, 6)),\n  # Select a number between 7 and 9 from a slider\n  sliderInput(inputId = \"slider_number\",\n              label = \"Pick a number\",\n              min = 7,\n              max = 9,\n              value = 8)\n)\n\n\nIn the user interface create a place for the output text for the product of these values to appear.\n\n\nui &lt;- fluidPage(\n  ...\n  # The output text\n  textOutput(outputId = \"output_text\")\n)\n\n\nCreate a server for the app that multiples the three input values together and renders their product as text. Hint: You will need to wrap each input in a as.numeric() function.\n\n\n# Server\nserver &lt;- function(input, output) {\n  # Render the product of the input values tas text\n  output$output_text &lt;- renderText({ \n    as.numeric(input$selected_number) * as.numeric(input$radio_number) * as.numeric(input$slider_number)\n  })\n}\n\n\nPut the parts together and run the app.\n\n\n# User Interface\nui &lt;- fluidPage(\n  # Select a number between 1 and 3 from a select dropdown menu\n  selectInput(inputId = \"selected_number\",\n              label = \"Pick a number\",\n              choices = c(1, 2, 3)),\n  # Select a number between 4 and 6 from radio buttons\n  radioButtons(inputId = \"radio_number\",\n               label = \"Pick a number\",\n               choices = c(4, 5, 6)),\n  # Select a number between 7 and 9 from a slider\n  sliderInput(inputId = \"slider_number\",\n              label = \"Pick a number\",\n              min = 7,\n              max = 9,\n              value = 8),\n  # The output text\n  textOutput(outputId = \"output_text\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n  # Render the product of the input values tas text\n  output$output_text &lt;- renderText({ \n    as.numeric(input$selected_number) * as.numeric(input$radio_number) * as.numeric(input$slider_number)\n  })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\nReuseCC-BY-4.0"
  },
  {
    "objectID": "lessons/03_visuals.html#providing-a-data-table-as-output",
    "href": "lessons/03_visuals.html#providing-a-data-table-as-output",
    "title": "Visualization and Interactive Visuals in RShiny",
    "section": "Providing a data table as output",
    "text": "Providing a data table as output\nShiny has some native data table functions, however using the DT package is recommended as it supports additional data table features. When you load DT it will mask the base Shiny functions dataTableOutput() with DTOutput() and renderDataTable() with renderDT(). In order to use the DT package, we will need to load it with:\n\nlibrary(DT)\n\nTo render a data table on the UI side you would use:\n\n# DO NOT RUN\nDTOutput(outputID = \"outputID\")\n\nOn the server side you would use:\n\n# DO NOT RUN\noutput$&lt;outputID&gt; &lt;- renderDT({\n    &lt;insert_dataframe&gt;\n  })\n\nLet’s use the built-in dataset mtcars to visualize an example of a data table within a Shiny app.\n\n# User interface\nui &lt;- fluidPage(\n    # Checkbox group to select which columns we would like to see in the data table\n    checkboxGroupInput(inputId = \"column_input\", \n                       label = \"Select columns\", \n                       choices = colnames(mtcars), \n                       inline = TRUE),\n    # The output table\n    DTOutput(\"table\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n    # Render the selected columns from mtcars as a data table\n    output$table &lt;- renderDT({\n        mtcars[,input$column_input, drop = FALSE]\n    })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\nOn the UI side:\n\nWe are using the input function described earlier checkboxGroupInput(), which will allow users to select which columns to display in the table.\nWe are using the DTOutput() funtion with “table” as the ID to correspond with the output object in the server side code\n\nOn the server side:\n\nWe use renderDT() and providing the mtcars dataframe, while using square brackets to subset the columns selected.\n\nThis will visualize in the app as:\n\n\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\nModify the app we just made which prints our output to a table to use selectInput() menu instead of checkboxGroupInput() in order to choose which column(s) we would like to see in our output table.",
    "crumbs": [
      "Day 1:",
      "Visualization and Interactive Visuals in RShiny"
    ]
  },
  {
    "objectID": "lessons/03_visuals-Answer_key.html",
    "href": "lessons/03_visuals-Answer_key.html",
    "title": "Input functions in RShiny - Answer Key",
    "section": "",
    "text": "Exercise 1\nModify the app we just created that prints our output to a table to use a selectInput() menu to choose which column(s) we would like to see in our output table.\n\n# User interface\nui &lt;- fluidPage(\n    # Use selectInput() to select which columns we would like to see in the data table\n    selectInput(inputId = \"column_input\", \n                       label = \"Select columns\", \n                       choices = colnames(mtcars), \n                       multiple = TRUE),\n    # The output table\n    DTOutput(\"table\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n    # Render the selected columns from mtcars as a data table\n    output$table &lt;- renderDT({\n        mtcars[,input$column_input, drop = FALSE]\n    })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\n\n\nExercise 2\nModify the above app to creates a boxplot with the number of cylinders on the x-axis and then allows the user to select the metric to visualize on the y-axas from a selectInput() menu.\nHint: You will need to set x = \"factor(cyl)\" in order for the aes_string() function to treat cyl as a column coming from the mtcars dataset rather than looking for a variable in your R environment called cyl.\n\n# User Interface\nui &lt;- fluidPage(\n  # Dropdown menu to select which column will be used for the y-axis\n  selectInput(inputId = \"y_axis_input\",\n              label = \"Select y-axis\",\n              choices = colnames(mtcars),\n              selected = \"disp\"),\n  # The output plot\n  plotOutput(outputId = \"plot\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n  # Render the scatter plot\n  output$plot &lt;- renderPlot({\n    # Scatter plot creation\n    # Importantly, we need to use aes_string() instead of aes() when the information is stored in an input object\n    ggplot(mtcars) +\n      geom_boxplot(aes_string(x = \"factor(cyl)\", y = input$y_axis_input)) +\n      xlab(\"Cylinders\")\n  })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\n\n\nExercise 3\nEdit the above app so that the fill of the brushed area is crimson (#A51C30) and the border is a nice blue (#3E6F7D).\n\n# User Interface\nui &lt;- fluidPage(\n    #  Plot the output with an interactive brushing argument\n    plotOutput(outputId = \"plot\",\n               brush = brushOpts(id = \"plot_brush\",\n                                fill = \"#A51C30\",\n                                stroke = \"#3E6F7D\",\n                                opacity = 0.7)\n    ),\n    # The output table\n    DTOutput(outputId = \"table\")\n)\n\n# Server\nserver &lt;- function(input, output) {\n    # Render a plot from the built-in mtcars dataset\n    output$plot &lt;- renderPlot(\n        ggplot(mtcars) +\n            geom_point(aes(x = mpg, y = disp))\n    )\n    # Render a table from points within the rectangle created by clicking and dragging over the plot\n    output$table &lt;- renderDT({\n        brushedPoints(mtcars, input$plot_brush)\n    })\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\nReuseCC-BY-4.0"
  },
  {
    "objectID": "schedule/schedule.html",
    "href": "schedule/schedule.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "schedule/schedule.html#workshop-schedule",
    "href": "schedule/schedule.html#workshop-schedule",
    "title": "",
    "section": "Workshop Schedule",
    "text": "Workshop Schedule\n\nDay 1\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n9:00 - 9:15\nWorkshop introduction\nWill\n\n\n9:15 - 9:35\nR Shiny App Structure and Syntax\nWill\n\n\n9:35 - 10:10\nInput options\nWill\n\n\n10:10 - 10:15\nBreak\n\n\n\n10:15 - 10:45\nVisualization and Interactive Visuals\nWill\n\n\n10:45 - 11:00\nPractical\nWill\n\n\n\n\n\nDay 2\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n09:00 - 9:20\nUploading and Downloading Data\nWill\n\n\n9:20 - 10:00\nLayouts\nWill\n\n\n10:00 - 10:05\nBreak\n\n\n\n10:05 - 10:25\nHosting Platforms\nWill\n\n\n10:25 - 10:50\nPractical\nWill\n\n\n10:50 - 11:00\nWorkshop Wrap-up\nWill"
  },
  {
    "objectID": "schedule/schedule.html#interesting-input-widgets",
    "href": "schedule/schedule.html#interesting-input-widgets",
    "title": "",
    "section": "Interesting Input Widgets",
    "text": "Interesting Input Widgets\n\nPicker\nshinyChakraSlider\n\n\nThese materials have been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited."
  },
  {
    "objectID": "schedule/self-learning.html",
    "href": "schedule/self-learning.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "schedule/self-learning.html#learning-objectives",
    "href": "schedule/self-learning.html#learning-objectives",
    "title": "",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nIn this workshop, users will be able to: - Differentiate between the User Interface and Server side of a RShiny App - Create apps that take a variety of input formats, including text, checkboxes, dropdown menus and sliders - Visualize text, figure and table output using an RShiny App - Upload data into an RShiny app and download data and figures from an RShiny app - Discuss the various hosting options for RShiny Apps - Modify R Shiny apps by editing a CSS file"
  },
  {
    "objectID": "schedule/self-learning.html#on-your-desktop",
    "href": "schedule/self-learning.html#on-your-desktop",
    "title": "",
    "section": "On your desktop",
    "text": "On your desktop\n\nR\nRStudio\nThe listed R packages"
  },
  {
    "objectID": "schedule/self-learning.html#interesting-input-widgets",
    "href": "schedule/self-learning.html#interesting-input-widgets",
    "title": "",
    "section": "Interesting Input Widgets",
    "text": "Interesting Input Widgets\n\nPicker\nshinyChakraSlider\n\n\nThese materials have been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited."
  },
  {
    "objectID": "schedule/schedule_AZ.html",
    "href": "schedule/schedule_AZ.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "schedule/schedule_AZ.html#workshop-schedule",
    "href": "schedule/schedule_AZ.html#workshop-schedule",
    "title": "",
    "section": "Workshop Schedule",
    "text": "Workshop Schedule\n\nDay 1\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n9:00 - 9:15\nWorkshop introduction\nWill\n\n\n9:15 - 9:35\nR Shiny App Structure and Syntax\nWill\n\n\n9:35 - 10:10\nInput options\nWill\n\n\n10:10 - 10:15\nBreak\n\n\n\n10:15 - 10:45\nVisualization and Interactive Visuals\nWill\n\n\n10:45 - 11:00\nPractical\nWill\n\n\n\n\n\nDay 2\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n09:00 - 9:20\nUploading and Downloading Data\nWill\n\n\n9:20 - 10:00\nLayouts\nWill\n\n\n10:00 - 10:05\nBreak\n\n\n\n10:05 - 10:25\nHosting Platforms\nWill\n\n\n10:25 - 10:50\nPractical\nWill\n\n\n10:50 - 11:00\nWorkshop Wrap-up\nWill"
  },
  {
    "objectID": "schedule/schedule_AZ.html#interesting-input-widgets",
    "href": "schedule/schedule_AZ.html#interesting-input-widgets",
    "title": "",
    "section": "Interesting Input Widgets",
    "text": "Interesting Input Widgets\n\nPicker\nshinyChakraSlider\n\n\nThese materials have been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited."
  }
]